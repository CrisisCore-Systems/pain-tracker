{"version":3,"file":"background-sync-DiQN0jqO.js","sources":["../../src/lib/background-sync.ts"],"sourcesContent":["/**\n * Background Sync Service\n * Handles synchronization of offline data when connection is restored\n */\n\nimport { offlineStorage } from './offline-storage';\nimport { secureStorage } from './storage/secureStorage';\n\ninterface SyncResult {\n  success: boolean;\n  itemId: number;\n  error?: string;\n  retryAfter?: number;\n}\n\ninterface SyncStats {\n  totalItems: number;\n  successCount: number;\n  failureCount: number;\n  skippedCount: number;\n  errors: string[];\n}\n\n// Shape of items stored in the sync queue (mirrors offlineStorage SyncQueueItem)\ninterface SyncQueueItemShape {\n  id?: number;\n  url: string;\n  method: string;\n  headers: Record<string, string>;\n  body?: string;\n  timestamp?: string;\n  priority: 'high' | 'medium' | 'low';\n  retryCount?: number;\n  type: string;\n  metadata?: Record<string, unknown>;\n}\n\n// Payload convenience types for public API methods\ntype GenericRecord = Record<string, unknown>;\ntype QueuePayload = GenericRecord | FormData | string | number | boolean | null | undefined;\n\nexport class BackgroundSyncService {\n  private static instance: BackgroundSyncService;\n  private isOnline: boolean = navigator.onLine;\n  private syncInProgress: boolean = false;\n  private retryTimeouts: Map<number, NodeJS.Timeout> = new Map();\n  private maxRetries: number = 3;\n  private retryDelays: number[] = [1000, 5000, 15000]; // Progressive delays in ms\n\n  private constructor() {\n    this.setupEventListeners();\n    this.startPeriodicSync();\n  }\n\n  static getInstance(): BackgroundSyncService {\n    if (!BackgroundSyncService.instance) {\n      BackgroundSyncService.instance = new BackgroundSyncService();\n    }\n    return BackgroundSyncService.instance;\n  }\n\n  private setupEventListeners(): void {\n    // Listen for online/offline events\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      console.log('BackgroundSync: Connection restored, starting sync');\n      this.syncAllPendingData();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      console.log('BackgroundSync: Connection lost');\n    });\n\n    // Listen for visibility change to sync when app becomes active\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'visible' && this.isOnline) {\n        this.syncAllPendingData();\n      }\n    });\n\n    // Listen for PWA events\n    window.addEventListener('pwa-online', () => {\n      this.isOnline = true;\n      this.syncAllPendingData();\n    });\n  }\n\n  private startPeriodicSync(): void {\n    // Sync every 5 minutes when online\n    setInterval(\n      () => {\n        if (this.isOnline && !this.syncInProgress) {\n          this.syncAllPendingData();\n        }\n      },\n      5 * 60 * 1000\n    );\n  }\n\n  async queueForSync(\n    url: string,\n    method: string,\n    data?: QueuePayload,\n    priority: 'high' | 'medium' | 'low' = 'medium'\n  ): Promise<void> {\n    try {\n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json',\n      };\n\n      // Add authentication headers if available\n      const token = secureStorage.get<string>('auth-token', { encrypt: true });\n      if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n      }\n\n      await offlineStorage.addToSyncQueue({\n        url,\n        method: method.toUpperCase(),\n        headers,\n        body: data ? JSON.stringify(data) : undefined,\n        priority,\n        type: 'api-request',\n      });\n\n      console.log(`BackgroundSync: Queued ${method} ${url} for sync`);\n\n      // Try to sync immediately if online\n      if (this.isOnline) {\n        this.syncAllPendingData();\n      }\n    } catch (error) {\n      console.error('BackgroundSync: Failed to queue item for sync:', error);\n      throw error;\n    }\n  }\n\n  async syncAllPendingData(): Promise<SyncStats> {\n    if (this.syncInProgress) {\n      console.log('BackgroundSync: Sync already in progress');\n      return this.getEmptyStats();\n    }\n\n    if (!this.isOnline) {\n      console.log('BackgroundSync: Cannot sync while offline');\n      return this.getEmptyStats();\n    }\n\n    this.syncInProgress = true;\n    console.log('BackgroundSync: Starting sync process');\n\n    const stats: SyncStats = {\n      totalItems: 0,\n      successCount: 0,\n      failureCount: 0,\n      skippedCount: 0,\n      errors: [],\n    };\n\n    try {\n      // Get all pending sync items\n      const syncQueue = await offlineStorage.getSyncQueue();\n      stats.totalItems = syncQueue.length;\n\n      if (syncQueue.length === 0) {\n        console.log('BackgroundSync: No items to sync');\n        return stats;\n      }\n\n      console.log(`BackgroundSync: Found ${syncQueue.length} items to sync`);\n\n      // Process each item\n      for (const item of syncQueue) {\n        try {\n          const result = await this.syncItem(item);\n\n          if (result.success) {\n            stats.successCount++;\n            await offlineStorage.removeSyncQueueItem(item.id!);\n            console.log(`BackgroundSync: Successfully synced ${item.method} ${item.url}`);\n          } else if (result.error) {\n            if ((item.retryCount || 0) >= this.maxRetries) {\n              stats.failureCount++;\n              stats.errors.push(`Max retries exceeded for ${item.url}: ${result.error}`);\n              await offlineStorage.removeSyncQueueItem(item.id!);\n              console.error(`BackgroundSync: Max retries exceeded for ${item.url}`);\n            } else {\n              // Schedule retry\n              await this.scheduleRetry(item, result);\n              stats.skippedCount++;\n            }\n          }\n        } catch (error) {\n          stats.failureCount++;\n          stats.errors.push(`Sync error for ${item.url}: ${error}`);\n          console.error(`BackgroundSync: Error syncing ${item.url}:`, error);\n        }\n      }\n\n      // Update local store if we synced pain entries\n      if (stats.successCount > 0) {\n        await this.updateLocalStore();\n      }\n\n      console.log('BackgroundSync: Sync completed', stats);\n      this.dispatchSyncEvent('sync-completed', stats);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error('BackgroundSync: Sync process failed:', error);\n      stats.errors.push(`Sync process failed: ${errorMessage}`);\n      this.dispatchSyncEvent('sync-error', { error: errorMessage });\n    } finally {\n      this.syncInProgress = false;\n    }\n\n    return stats;\n  }\n\n  private async syncItem(item: SyncQueueItemShape): Promise<SyncResult> {\n    try {\n      // Check if we're still online\n      if (!this.isOnline) {\n        return { success: false, itemId: item.id!, error: 'Offline' };\n      }\n\n      const response = await fetch(item.url, {\n        method: item.method,\n        headers: item.headers,\n        body: item.body,\n      });\n\n      if (response.ok) {\n        return { success: true, itemId: item.id! };\n      } else {\n        let errorMessage = `HTTP ${response.status}`;\n\n        try {\n          const errorData = await response.json();\n          errorMessage = errorData.message || errorMessage;\n        } catch {\n          errorMessage = response.statusText || errorMessage;\n        }\n\n        // Determine if we should retry based on status code\n        const shouldRetry = response.status >= 500 || response.status === 429;\n\n        return {\n          success: false,\n          itemId: item.id!,\n          error: errorMessage,\n          retryAfter: shouldRetry ? this.getRetryDelay(item.retryCount || 0) : undefined,\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        itemId: item.id!,\n        error: error instanceof Error ? error.message : 'Network error',\n      };\n    }\n  }\n\n  private async scheduleRetry(item: SyncQueueItemShape, result: SyncResult): Promise<void> {\n    const delay = result.retryAfter || this.getRetryDelay(item.retryCount || 0);\n\n    // Clear existing timeout for this item\n    if (this.retryTimeouts.has(item.id!)) {\n      clearTimeout(this.retryTimeouts.get(item.id!)!);\n    }\n\n    // Update retry count\n    await offlineStorage.updateSyncQueueItem(item.id!, {\n      retryCount: (item.retryCount || 0) + 1,\n    });\n\n    // Schedule retry\n    const timeout = setTimeout(() => {\n      this.retryTimeouts.delete(item.id!);\n      this.syncAllPendingData();\n    }, delay);\n\n    this.retryTimeouts.set(item.id!, timeout);\n\n    console.log(`BackgroundSync: Scheduled retry for ${item.url} in ${delay}ms`);\n  }\n\n  private getRetryDelay(retryCount: number): number {\n    if (retryCount < this.retryDelays.length) {\n      return this.retryDelays[retryCount];\n    }\n    // Exponential backoff for higher retry counts\n    return Math.min(\n      30000,\n      this.retryDelays[this.retryDelays.length - 1] *\n        Math.pow(2, retryCount - this.retryDelays.length)\n    );\n  }\n\n  private async updateLocalStore(): Promise<void> {\n    try {\n      // Get all unsynced data\n      const unsyncedData = await offlineStorage.getUnsyncedData();\n\n      // Update Zustand store with synced data\n      for (const item of unsyncedData) {\n        if (item.type === 'pain-entry' && item.synced) {\n          // Update the entry in the store to reflect sync status\n          // This could include updating a 'synced' flag or handling conflicts\n        }\n      }\n    } catch (error) {\n      console.error('BackgroundSync: Failed to update local store:', error);\n    }\n  }\n\n  private getEmptyStats(): SyncStats {\n    return {\n      totalItems: 0,\n      successCount: 0,\n      failureCount: 0,\n      skippedCount: 0,\n      errors: [],\n    };\n  }\n\n  private dispatchSyncEvent(type: string, detail: unknown): void {\n    const event = new CustomEvent(`background-sync-${type}`, { detail });\n    window.dispatchEvent(event);\n  }\n\n  // Public methods for managing sync\n  async forcSync(): Promise<SyncStats> {\n    // cspell:ignore forc\n    console.log('BackgroundSync: Force sync requested');\n    return this.syncAllPendingData();\n  }\n\n  // Backwards-compatible correctly spelled alias - prefer this going forward\n  async forceSync(): Promise<SyncStats> {\n    return this.forcSync();\n  }\n\n  async clearFailedItems(): Promise<void> {\n    try {\n      const syncQueue = await offlineStorage.getSyncQueue();\n      const failedItems = syncQueue.filter(item => (item.retryCount || 0) >= this.maxRetries);\n\n      await Promise.all(failedItems.map(item => offlineStorage.removeSyncQueueItem(item.id!)));\n\n      console.log(`BackgroundSync: Cleared ${failedItems.length} failed items`);\n    } catch (error) {\n      console.error('BackgroundSync: Failed to clear failed items:', error);\n    }\n  }\n\n  async getPendingItemsCount(): Promise<number> {\n    try {\n      const syncQueue = await offlineStorage.getSyncQueue();\n      return syncQueue.length;\n    } catch (error) {\n      console.error('BackgroundSync: Failed to get pending items count:', error);\n      return 0;\n    }\n  }\n\n  getSyncStatus(): { isOnline: boolean; isSyncing: boolean } {\n    return {\n      isOnline: this.isOnline,\n      isSyncing: this.syncInProgress,\n    };\n  }\n\n  // Emergency sync for critical data\n  async emergencySync(data: QueuePayload, endpoint: string): Promise<boolean> {\n    if (!this.isOnline) {\n      await this.queueForSync(endpoint, 'POST', data, 'high');\n      return false;\n    }\n\n    try {\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${secureStorage.get<string>('auth-token', { encrypt: true }) || ''}`,\n        },\n        body: JSON.stringify(data),\n      });\n\n      if (response.ok) {\n        console.log('BackgroundSync: Emergency sync successful');\n        return true;\n      } else {\n        // Queue for retry even if it failed\n        await this.queueForSync(endpoint, 'POST', data, 'high');\n        return false;\n      }\n    } catch (error) {\n      console.error('BackgroundSync: Emergency sync failed:', error);\n      await this.queueForSync(endpoint, 'POST', data, 'high');\n      return false;\n    }\n  }\n}\n\n// Background sync helper for pain tracker specific operations\nexport class PainTrackerSync {\n  private backgroundSync: BackgroundSyncService;\n  private baseUrl: string;\n\n  constructor() {\n    this.backgroundSync = BackgroundSyncService.getInstance();\n    this.baseUrl = import.meta.env.VITE_API_BASE_URL || '/api';\n  }\n\n  async syncPainEntry(entry: QueuePayload): Promise<void> {\n    const endpoint = `${this.baseUrl}/pain-entries`;\n    await this.backgroundSync.queueForSync(endpoint, 'POST', entry, 'high');\n  }\n\n  async syncPainEntryUpdate(id: number, updates: QueuePayload): Promise<void> {\n    const endpoint = `${this.baseUrl}/pain-entries/${id}`;\n    await this.backgroundSync.queueForSync(endpoint, 'PUT', updates, 'medium');\n  }\n\n  async syncEmergencyData(data: QueuePayload): Promise<boolean> {\n    const endpoint = `${this.baseUrl}/emergency`;\n    return this.backgroundSync.emergencySync(data, endpoint);\n  }\n\n  async syncActivityLog(log: QueuePayload): Promise<void> {\n    const endpoint = `${this.baseUrl}/activity-logs`;\n    await this.backgroundSync.queueForSync(endpoint, 'POST', log, 'low');\n  }\n\n  async syncSettings(settings: QueuePayload): Promise<void> {\n    const endpoint = `${this.baseUrl}/settings`;\n    await this.backgroundSync.queueForSync(endpoint, 'PUT', settings, 'low');\n  }\n\n  // Get sync status specifically for pain tracker data\n  async getSyncStatus(): Promise<{\n    pendingEntries: number;\n    lastSync: string | null;\n    isOnline: boolean;\n    isSyncing: boolean;\n  }> {\n    const syncQueue = await offlineStorage.getSyncQueue();\n    const painEntryQueue = syncQueue.filter(item => item.url.includes('/pain-entries'));\n\n    const lastSyncTime = secureStorage.get<string>('last-sync-time');\n    const { isOnline, isSyncing } = this.backgroundSync.getSyncStatus();\n\n    return {\n      pendingEntries: painEntryQueue.length,\n      lastSync: lastSyncTime,\n      isOnline,\n      isSyncing,\n    };\n  }\n\n  async forceSync(): Promise<void> {\n    const stats = await this.backgroundSync.forceSync();\n\n    if (stats.successCount > 0) {\n      secureStorage.set('last-sync-time', new Date().toISOString());\n    }\n  }\n}\n\n// Export singleton instances\nexport const backgroundSync = BackgroundSyncService.getInstance();\nexport const painTrackerSync = new PainTrackerSync();\n"],"names":["BackgroundSyncService","static","isOnline","navigator","onLine","syncInProgress","retryTimeouts","Map","maxRetries","retryDelays","constructor","this","setupEventListeners","startPeriodicSync","getInstance","instance","window","addEventListener","syncAllPendingData","document","visibilityState","setInterval","queueForSync","url","method","data","priority","headers","token","secureStorage","get","encrypt","offlineStorage","addToSyncQueue","toUpperCase","body","JSON","stringify","type","error","getEmptyStats","stats","totalItems","successCount","failureCount","skippedCount","errors","syncQueue","getSyncQueue","length","item","result","syncItem","success","removeSyncQueueItem","id","retryCount","push","scheduleRetry","updateLocalStore","dispatchSyncEvent","errorMessage","Error","message","String","itemId","response","fetch","ok","status","json","statusText","shouldRetry","retryAfter","getRetryDelay","delay","has","clearTimeout","updateSyncQueueItem","timeout","setTimeout","delete","set","Math","min","pow","unsyncedData","getUnsyncedData","synced","detail","event","CustomEvent","dispatchEvent","forcSync","forceSync","clearFailedItems","failedItems","filter","Promise","all","map","getPendingItemsCount","getSyncStatus","isSyncing","emergencySync","endpoint","Authorization","PainTrackerSync","backgroundSync","baseUrl","syncPainEntry","entry","syncPainEntryUpdate","updates","syncEmergencyData","syncActivityLog","log","syncSettings","settings","painEntryQueue","includes","lastSyncTime","pendingEntries","lastSync","Date","toISOString","painTrackerSync"],"mappings":"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"}