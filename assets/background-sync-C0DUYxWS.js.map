{"version":3,"file":"background-sync-C0DUYxWS.js","sources":["../../src/lib/background-sync.ts"],"sourcesContent":["/**\n * Background Sync Service\n * Handles synchronization of offline data when connection is restored\n */\n\nimport { offlineStorage } from './offline-storage';\nimport { secureStorage } from './storage/secureStorage';\n\ninterface SyncResult {\n  success: boolean;\n  itemId: number;\n  error?: string;\n  retryAfter?: number;\n}\n\ninterface SyncStats {\n  totalItems: number;\n  successCount: number;\n  failureCount: number;\n  skippedCount: number;\n  errors: string[];\n}\n\n// Shape of items stored in the sync queue (mirrors offlineStorage SyncQueueItem)\ninterface SyncQueueItemShape {\n  id?: number;\n  url: string;\n  method: string;\n  headers: Record<string, string>;\n  body?: string;\n  timestamp?: string;\n  priority: 'high' | 'medium' | 'low';\n  retryCount?: number;\n  type: string;\n  metadata?: Record<string, unknown>;\n}\n\n// Payload convenience types for public API methods\ntype GenericRecord = Record<string, unknown>;\ntype QueuePayload = GenericRecord | FormData | string | number | boolean | null | undefined;\n\nexport class BackgroundSyncService {\n  private static instance: BackgroundSyncService;\n  private isOnline: boolean = navigator.onLine;\n  private syncInProgress: boolean = false;\n  private retryTimeouts: Map<number, NodeJS.Timeout> = new Map();\n  private maxRetries: number = 3;\n  private retryDelays: number[] = [1000, 5000, 15000]; // Progressive delays in ms\n\n  private constructor() {\n    this.setupEventListeners();\n    this.startPeriodicSync();\n  }\n\n  static getInstance(): BackgroundSyncService {\n    if (!BackgroundSyncService.instance) {\n      BackgroundSyncService.instance = new BackgroundSyncService();\n    }\n    return BackgroundSyncService.instance;\n  }\n\n  private setupEventListeners(): void {\n    // Listen for online/offline events\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      console.log('BackgroundSync: Connection restored, starting sync');\n      this.syncAllPendingData();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      console.log('BackgroundSync: Connection lost');\n    });\n\n    // Listen for visibility change to sync when app becomes active\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'visible' && this.isOnline) {\n        this.syncAllPendingData();\n      }\n    });\n\n    // Listen for PWA events\n    window.addEventListener('pwa-online', () => {\n      this.isOnline = true;\n      this.syncAllPendingData();\n    });\n  }\n\n  private startPeriodicSync(): void {\n    // Sync every 5 minutes when online\n    setInterval(\n      () => {\n        if (this.isOnline && !this.syncInProgress) {\n          this.syncAllPendingData();\n        }\n      },\n      5 * 60 * 1000\n    );\n  }\n\n  async queueForSync(\n    url: string,\n    method: string,\n    data?: QueuePayload,\n    priority: 'high' | 'medium' | 'low' = 'medium'\n  ): Promise<void> {\n    try {\n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json',\n      };\n\n      // Add authentication headers if available\n      const token = secureStorage.get<string>('auth-token', { encrypt: true });\n      if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n      }\n\n      await offlineStorage.addToSyncQueue({\n        url,\n        method: method.toUpperCase(),\n        headers,\n        body: data ? JSON.stringify(data) : undefined,\n        priority,\n        type: 'api-request',\n      });\n\n      console.log(`BackgroundSync: Queued ${method} ${url} for sync`);\n\n      // Try to sync immediately if online\n      if (this.isOnline) {\n        this.syncAllPendingData();\n      }\n    } catch (error) {\n      console.error('BackgroundSync: Failed to queue item for sync:', error);\n      throw error;\n    }\n  }\n\n  async syncAllPendingData(): Promise<SyncStats> {\n    if (this.syncInProgress) {\n      console.log('BackgroundSync: Sync already in progress');\n      return this.getEmptyStats();\n    }\n\n    if (!this.isOnline) {\n      console.log('BackgroundSync: Cannot sync while offline');\n      return this.getEmptyStats();\n    }\n\n    this.syncInProgress = true;\n    console.log('BackgroundSync: Starting sync process');\n\n    const stats: SyncStats = {\n      totalItems: 0,\n      successCount: 0,\n      failureCount: 0,\n      skippedCount: 0,\n      errors: [],\n    };\n\n    try {\n      // Get all pending sync items\n      const syncQueue = await offlineStorage.getSyncQueue();\n      stats.totalItems = syncQueue.length;\n\n      if (syncQueue.length === 0) {\n        console.log('BackgroundSync: No items to sync');\n        return stats;\n      }\n\n      console.log(`BackgroundSync: Found ${syncQueue.length} items to sync`);\n\n      // Process each item\n      for (const item of syncQueue) {\n        try {\n          const result = await this.syncItem(item);\n\n          if (result.success) {\n            stats.successCount++;\n            await offlineStorage.removeSyncQueueItem(item.id!);\n            console.log(`BackgroundSync: Successfully synced ${item.method} ${item.url}`);\n          } else if (result.error) {\n            if ((item.retryCount || 0) >= this.maxRetries) {\n              stats.failureCount++;\n              stats.errors.push(`Max retries exceeded for ${item.url}: ${result.error}`);\n              await offlineStorage.removeSyncQueueItem(item.id!);\n              console.error(`BackgroundSync: Max retries exceeded for ${item.url}`);\n            } else {\n              // Schedule retry\n              await this.scheduleRetry(item, result);\n              stats.skippedCount++;\n            }\n          }\n        } catch (error) {\n          stats.failureCount++;\n          stats.errors.push(`Sync error for ${item.url}: ${error}`);\n          console.error(`BackgroundSync: Error syncing ${item.url}:`, error);\n        }\n      }\n\n      // Update local store if we synced pain entries\n      if (stats.successCount > 0) {\n        await this.updateLocalStore();\n      }\n\n      console.log('BackgroundSync: Sync completed', stats);\n      this.dispatchSyncEvent('sync-completed', stats);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error('BackgroundSync: Sync process failed:', error);\n      stats.errors.push(`Sync process failed: ${errorMessage}`);\n      this.dispatchSyncEvent('sync-error', { error: errorMessage });\n    } finally {\n      this.syncInProgress = false;\n    }\n\n    return stats;\n  }\n\n  private async syncItem(item: SyncQueueItemShape): Promise<SyncResult> {\n    try {\n      // Check if we're still online\n      if (!this.isOnline) {\n        return { success: false, itemId: item.id!, error: 'Offline' };\n      }\n\n      const response = await fetch(item.url, {\n        method: item.method,\n        headers: item.headers,\n        body: item.body,\n      });\n\n      if (response.ok) {\n        return { success: true, itemId: item.id! };\n      } else {\n        let errorMessage = `HTTP ${response.status}`;\n\n        try {\n          const errorData = await response.json();\n          errorMessage = errorData.message || errorMessage;\n        } catch {\n          errorMessage = response.statusText || errorMessage;\n        }\n\n        // Determine if we should retry based on status code\n        const shouldRetry = response.status >= 500 || response.status === 429;\n\n        return {\n          success: false,\n          itemId: item.id!,\n          error: errorMessage,\n          retryAfter: shouldRetry ? this.getRetryDelay(item.retryCount || 0) : undefined,\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        itemId: item.id!,\n        error: error instanceof Error ? error.message : 'Network error',\n      };\n    }\n  }\n\n  private async scheduleRetry(item: SyncQueueItemShape, result: SyncResult): Promise<void> {\n    const delay = result.retryAfter || this.getRetryDelay(item.retryCount || 0);\n\n    // Clear existing timeout for this item\n    if (this.retryTimeouts.has(item.id!)) {\n      clearTimeout(this.retryTimeouts.get(item.id!)!);\n    }\n\n    // Update retry count\n    await offlineStorage.updateSyncQueueItem(item.id!, {\n      retryCount: (item.retryCount || 0) + 1,\n    });\n\n    // Schedule retry\n    const timeout = setTimeout(() => {\n      this.retryTimeouts.delete(item.id!);\n      this.syncAllPendingData();\n    }, delay);\n\n    this.retryTimeouts.set(item.id!, timeout);\n\n    console.log(`BackgroundSync: Scheduled retry for ${item.url} in ${delay}ms`);\n  }\n\n  private getRetryDelay(retryCount: number): number {\n    if (retryCount < this.retryDelays.length) {\n      return this.retryDelays[retryCount];\n    }\n    // Exponential backoff for higher retry counts\n    return Math.min(\n      30000,\n      this.retryDelays[this.retryDelays.length - 1] *\n        Math.pow(2, retryCount - this.retryDelays.length)\n    );\n  }\n\n  private async updateLocalStore(): Promise<void> {\n    try {\n      // Get all unsynced data\n      const unsyncedData = await offlineStorage.getUnsyncedData();\n\n      // Update Zustand store with synced data\n      for (const item of unsyncedData) {\n        if (item.type === 'pain-entry' && item.synced) {\n          // Update the entry in the store to reflect sync status\n          // This could include updating a 'synced' flag or handling conflicts\n        }\n      }\n    } catch (error) {\n      console.error('BackgroundSync: Failed to update local store:', error);\n    }\n  }\n\n  private getEmptyStats(): SyncStats {\n    return {\n      totalItems: 0,\n      successCount: 0,\n      failureCount: 0,\n      skippedCount: 0,\n      errors: [],\n    };\n  }\n\n  private dispatchSyncEvent(type: string, detail: unknown): void {\n    const event = new CustomEvent(`background-sync-${type}`, { detail });\n    window.dispatchEvent(event);\n  }\n\n  // Public methods for managing sync\n  async forcSync(): Promise<SyncStats> {\n    // cspell:ignore forc\n    console.log('BackgroundSync: Force sync requested');\n    return this.syncAllPendingData();\n  }\n\n  // Backwards-compatible correctly spelled alias - prefer this going forward\n  async forceSync(): Promise<SyncStats> {\n    return this.forcSync();\n  }\n\n  async clearFailedItems(): Promise<void> {\n    try {\n      const syncQueue = await offlineStorage.getSyncQueue();\n      const failedItems = syncQueue.filter(item => (item.retryCount || 0) >= this.maxRetries);\n\n      await Promise.all(failedItems.map(item => offlineStorage.removeSyncQueueItem(item.id!)));\n\n      console.log(`BackgroundSync: Cleared ${failedItems.length} failed items`);\n    } catch (error) {\n      console.error('BackgroundSync: Failed to clear failed items:', error);\n    }\n  }\n\n  async getPendingItemsCount(): Promise<number> {\n    try {\n      const syncQueue = await offlineStorage.getSyncQueue();\n      return syncQueue.length;\n    } catch (error) {\n      console.error('BackgroundSync: Failed to get pending items count:', error);\n      return 0;\n    }\n  }\n\n  getSyncStatus(): { isOnline: boolean; isSyncing: boolean } {\n    return {\n      isOnline: this.isOnline,\n      isSyncing: this.syncInProgress,\n    };\n  }\n\n  // Emergency sync for critical data\n  async emergencySync(data: QueuePayload, endpoint: string): Promise<boolean> {\n    if (!this.isOnline) {\n      await this.queueForSync(endpoint, 'POST', data, 'high');\n      return false;\n    }\n\n    try {\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${secureStorage.get<string>('auth-token', { encrypt: true }) || ''}`,\n        },\n        body: JSON.stringify(data),\n      });\n\n      if (response.ok) {\n        console.log('BackgroundSync: Emergency sync successful');\n        return true;\n      } else {\n        // Queue for retry even if it failed\n        await this.queueForSync(endpoint, 'POST', data, 'high');\n        return false;\n      }\n    } catch (error) {\n      console.error('BackgroundSync: Emergency sync failed:', error);\n      await this.queueForSync(endpoint, 'POST', data, 'high');\n      return false;\n    }\n  }\n}\n\n// Background sync helper for pain tracker specific operations\nexport class PainTrackerSync {\n  private backgroundSync: BackgroundSyncService;\n  private baseUrl: string;\n\n  constructor() {\n    this.backgroundSync = BackgroundSyncService.getInstance();\n    this.baseUrl = import.meta.env.VITE_API_BASE_URL || '/api';\n  }\n\n  async syncPainEntry(entry: QueuePayload): Promise<void> {\n    const endpoint = `${this.baseUrl}/pain-entries`;\n    await this.backgroundSync.queueForSync(endpoint, 'POST', entry, 'high');\n  }\n\n  async syncPainEntryUpdate(id: number, updates: QueuePayload): Promise<void> {\n    const endpoint = `${this.baseUrl}/pain-entries/${id}`;\n    await this.backgroundSync.queueForSync(endpoint, 'PUT', updates, 'medium');\n  }\n\n  async syncEmergencyData(data: QueuePayload): Promise<boolean> {\n    const endpoint = `${this.baseUrl}/emergency`;\n    return this.backgroundSync.emergencySync(data, endpoint);\n  }\n\n  async syncActivityLog(log: QueuePayload): Promise<void> {\n    const endpoint = `${this.baseUrl}/activity-logs`;\n    await this.backgroundSync.queueForSync(endpoint, 'POST', log, 'low');\n  }\n\n  async syncSettings(settings: QueuePayload): Promise<void> {\n    const endpoint = `${this.baseUrl}/settings`;\n    await this.backgroundSync.queueForSync(endpoint, 'PUT', settings, 'low');\n  }\n\n  // Get sync status specifically for pain tracker data\n  async getSyncStatus(): Promise<{\n    pendingEntries: number;\n    lastSync: string | null;\n    isOnline: boolean;\n    isSyncing: boolean;\n  }> {\n    const syncQueue = await offlineStorage.getSyncQueue();\n    const painEntryQueue = syncQueue.filter(item => item.url.includes('/pain-entries'));\n\n    const lastSyncTime = secureStorage.get<string>('last-sync-time');\n    const { isOnline, isSyncing } = this.backgroundSync.getSyncStatus();\n\n    return {\n      pendingEntries: painEntryQueue.length,\n      lastSync: lastSyncTime,\n      isOnline,\n      isSyncing,\n    };\n  }\n\n  async forceSync(): Promise<void> {\n    const stats = await this.backgroundSync.forceSync();\n\n    if (stats.successCount > 0) {\n      secureStorage.set('last-sync-time', new Date().toISOString());\n    }\n  }\n}\n\n// Export singleton instances\nexport const backgroundSync = BackgroundSyncService.getInstance();\nexport const painTrackerSync = new PainTrackerSync();\n"],"names":["BackgroundSyncService","url","method","data","priority","headers","token","secureStorage","offlineStorage","error","stats","syncQueue","item","result","errorMessage","response","shouldRetry","delay","timeout","retryCount","unsyncedData","type","detail","event","failedItems","endpoint","PainTrackerSync","entry","id","updates","log","settings","painEntryQueue","lastSyncTime","isOnline","isSyncing","backgroundSync","painTrackerSync"],"mappings":"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"}