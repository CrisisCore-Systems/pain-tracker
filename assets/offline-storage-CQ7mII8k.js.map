{"version":3,"file":"offline-storage-CQ7mII8k.js","sources":["../../src/lib/offline-storage.ts"],"sourcesContent":["/**\r\n * Offline Storage Service using IndexedDB\r\n * Provides robust data persistence for PWA offline functionality\r\n */\r\n\r\n// Define specific data types for better type safety\r\ntype PainEntryData = {\r\n  pain_level: number;\r\n  location: string;\r\n  description?: string;\r\n  triggers?: string[];\r\n  medications?: string[];\r\n  activities?: string[];\r\n  mood?: string;\r\n  weather?: string;\r\n  notes?: string;\r\n};\r\n\r\ntype EmergencyData = {\r\n  contactName: string;\r\n  phoneNumber: string;\r\n  relationship: string;\r\n  medicalInfo?: string;\r\n  allergies?: string[];\r\n  medications?: string[];\r\n};\r\n\r\ntype ActivityLogData = {\r\n  activity: string;\r\n  duration?: number;\r\n  intensity?: number;\r\n  painBefore?: number;\r\n  painAfter?: number;\r\n  notes?: string;\r\n};\r\n\r\ntype SettingsData = {\r\n  key: string;\r\n  value: unknown;\r\n} | {\r\n  [key: string]: unknown;\r\n};\r\n\r\ntype SyncQueueData = {\r\n  operation: string;\r\n  payload: unknown;\r\n  priority: 'high' | 'medium' | 'low';\r\n};\r\n\r\ntype StoredDataPayload = PainEntryData | EmergencyData | ActivityLogData | SettingsData | SyncQueueData;\r\n\r\ninterface StoredData {\r\n  id?: number;\r\n  timestamp: string;\r\n  type: 'pain-entry' | 'emergency-data' | 'activity-log' | 'settings' | 'sync-queue';\r\n  data: StoredDataPayload;\r\n  synced?: boolean;\r\n  lastModified: string;\r\n}\r\n\r\ninterface SyncQueueItem {\r\n  id?: number;\r\n  url: string;\r\n  method: string;\r\n  headers: Record<string, string>;\r\n  body?: string;\r\n  timestamp: string;\r\n  priority: 'high' | 'medium' | 'low';\r\n  retryCount?: number;\r\n  type: string;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\nexport class OfflineStorageService {\r\n  private dbName = 'pain-tracker-offline';\r\n  private dbVersion = 1;\r\n  private db: IDBDatabase | null = null;\r\n  private static _instance: OfflineStorageService | null = null;\r\n\r\n  // Store names\r\n  private stores = {\r\n    data: 'offline-data',\r\n    syncQueue: 'sync-queue',\r\n    cache: 'cache-metadata'\r\n  };\r\n\r\n  async init(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(this.dbName, this.dbVersion);\r\n\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => {\r\n        this.db = request.result;\r\n        resolve();\r\n      };\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result;\r\n\r\n        // Offline data store\r\n        if (!db.objectStoreNames.contains(this.stores.data)) {\r\n          const dataStore = db.createObjectStore(this.stores.data, {\r\n            keyPath: 'id',\r\n            autoIncrement: true\r\n          });\r\n          dataStore.createIndex('type', 'type', { unique: false });\r\n          dataStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n          dataStore.createIndex('synced', 'synced', { unique: false });\r\n        }\r\n\r\n        // Sync queue store\r\n        if (!db.objectStoreNames.contains(this.stores.syncQueue)) {\r\n          const syncStore = db.createObjectStore(this.stores.syncQueue, {\r\n            keyPath: 'id',\r\n            autoIncrement: true\r\n          });\r\n          syncStore.createIndex('priority', 'priority', { unique: false });\r\n          syncStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n          syncStore.createIndex('retryCount', 'retryCount', { unique: false });\r\n        }\r\n\r\n        // Cache metadata store\r\n        if (!db.objectStoreNames.contains(this.stores.cache)) {\r\n          const cacheStore = db.createObjectStore(this.stores.cache, {\r\n            keyPath: 'url'\r\n          });\r\n          cacheStore.createIndex('expiry', 'expiry', { unique: false });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  // Key-value helpers (backed by EnhancedLocalStorage and IndexedDB settings)\r\n  async setItem(key: string, value: unknown): Promise<void> {\r\n    try {\r\n      // Store in localStorage for fast access and in IndexedDB for durability\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n    } catch {\r\n      // ignore localStorage failures\r\n    }\r\n    await this.storeData('settings', { key, value });\r\n  }\r\n\r\n  async getItem<T = unknown>(key: string): Promise<T | null> {\r\n    try {\r\n      const v = localStorage.getItem(key);\r\n      if (v !== null) return JSON.parse(v) as T;\r\n    } catch {\r\n      // ignore\r\n    }\r\n    try {\r\n      const settings = await this.getData('settings');\r\n      const match = settings.find(s => s.data && typeof s.data === 'object' && 'key' in s.data && (s.data as Record<string, unknown>).key === key);\r\n      if (match && match.data && typeof match.data === 'object' && 'value' in match.data) {\r\n        return (match.data as Record<string, unknown>).value as T;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Table-like helpers implemented via settings key prefixes: table:{tableName}:{id}\r\n  private makeTableKey(tableName: string, id: string): string {\r\n    return `table:${tableName}:${id}`;\r\n  }\r\n\r\n  private parseTableKey(key: string): { table: string; id: string } | null {\r\n    if (!key.startsWith('table:')) return null;\r\n    const parts = key.split(':');\r\n    if (parts.length < 3) return null;\r\n    return { table: parts[1], id: parts.slice(2).join(':') };\r\n    }\r\n\r\n  async getAllFromTable<T = unknown>(tableName: string): Promise<T[]> {\r\n    const settings = await this.getData('settings');\r\n    const items: T[] = [];\r\n    for (const entry of settings) {\r\n      if (entry.data && typeof entry.data === 'object' && 'key' in entry.data && 'value' in entry.data) {\r\n        const key = (entry.data as Record<string, unknown>).key as string;\r\n        const parsed = this.parseTableKey(key);\r\n        if (parsed && parsed.table === tableName) {\r\n          items.push((entry.data as Record<string, unknown>).value as T);\r\n        }\r\n      }\r\n    }\r\n    return items;\r\n  }\r\n\r\n  async replaceTable<T = unknown>(tableName: string, items: T[]): Promise<void> {\r\n    const settings = await this.getData('settings');\r\n    // Remove existing rows for table\r\n    const deletions: Promise<void>[] = [];\r\n    for (const entry of settings) {\r\n      if (entry.id !== undefined && entry.data && typeof entry.data === 'object' && 'key' in entry.data) {\r\n        const key = (entry.data as Record<string, unknown>).key as string;\r\n        const parsed = this.parseTableKey(key);\r\n        if (parsed && parsed.table === tableName) {\r\n          deletions.push(this.deleteData(entry.id));\r\n        }\r\n      }\r\n    }\r\n    await Promise.allSettled(deletions);\r\n    // Add new items\r\n    for (const item of items) {\r\n      const id = (item as unknown as { id?: string }).id || crypto.randomUUID();\r\n      await this.storeData('settings', { key: this.makeTableKey(tableName, String(id)), value: item });\r\n    }\r\n  }\r\n\r\n  async addToTable<T = unknown>(tableName: string, item: T & { id?: string }): Promise<void> {\r\n    const id = item.id || crypto.randomUUID();\r\n    await this.storeData('settings', { key: this.makeTableKey(tableName, String(id)), value: { ...item, id } });\r\n  }\r\n\r\n  async updateInTable<T = unknown>(tableName: string, id: string | number, item: T): Promise<void> {\r\n    const settings = await this.getData('settings');\r\n    const keyToFind = this.makeTableKey(tableName, String(id));\r\n    const match = settings.find(s => s.data && typeof s.data === 'object' && 'key' in s.data && (s.data as Record<string, unknown>).key === keyToFind);\r\n    if (match && match.id !== undefined) {\r\n      await this.updateData(match.id, { key: keyToFind, value: item });\r\n    } else {\r\n      // If not found, add\r\n      await this.storeData('settings', { key: keyToFind, value: item });\r\n    }\r\n  }\r\n\r\n  async removeFromTable(tableName: string, id: string | number): Promise<void> {\r\n    const settings = await this.getData('settings');\r\n    const keyToFind = this.makeTableKey(tableName, String(id));\r\n    const match = settings.find(s => s.data && typeof s.data === 'object' && 'key' in s.data && (s.data as Record<string, unknown>).key === keyToFind);\r\n    if (match && match.id !== undefined) {\r\n      await this.deleteData(match.id);\r\n    }\r\n  }\r\n\r\n  async getFromTable<T = unknown>(tableName: string, id: string | number): Promise<T | null> {\r\n    const settings = await this.getData('settings');\r\n    const keyToFind = this.makeTableKey(tableName, String(id));\r\n    const match = settings.find(s => s.data && typeof s.data === 'object' && 'key' in s.data && (s.data as Record<string, unknown>).key === keyToFind);\r\n    if (match && match.data && typeof match.data === 'object' && 'value' in match.data) {\r\n      return (match.data as Record<string, unknown>).value as T;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Data Storage Methods\r\n  async storeData(type: StoredData['type'], data: StoredDataPayload): Promise<number> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const storedData: StoredData = {\r\n        timestamp: new Date().toISOString(),\r\n        type,\r\n        data,\r\n        synced: false,\r\n        lastModified: new Date().toISOString()\r\n      };\r\n\r\n      const request = store.add(storedData);\r\n      request.onsuccess = () => resolve(request.result as number);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async updateData(id: number, data: StoredDataPayload): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const getRequest = store.get(id);\r\n      getRequest.onsuccess = () => {\r\n        const existing = getRequest.result;\r\n        if (existing) {\r\n          existing.data = data;\r\n          existing.lastModified = new Date().toISOString();\r\n          existing.synced = false;\r\n\r\n          const updateRequest = store.put(existing);\r\n          updateRequest.onsuccess = () => resolve();\r\n          updateRequest.onerror = () => reject(updateRequest.error);\r\n        } else {\r\n          reject(new Error('Data not found'));\r\n        }\r\n      };\r\n      getRequest.onerror = () => reject(getRequest.error);\r\n    });\r\n  }\r\n\r\n  async getData(type: StoredData['type']): Promise<StoredData[]> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\r\n      const store = transaction.objectStore(this.stores.data);\r\n      const index = store.index('type');\r\n\r\n      const request = index.getAll(type);\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async getUnsyncedData(): Promise<StoredData[]> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\r\n      const store = transaction.objectStore(this.stores.data);\r\n      const index = store.index('synced');\r\n\r\n      const request = index.getAll(0); // Use 0 instead of false for unsynced items\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async markAsSynced(id: number): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const getRequest = store.get(id);\r\n      getRequest.onsuccess = () => {\r\n        const data = getRequest.result;\r\n        if (data) {\r\n          data.synced = true;\r\n          const updateRequest = store.put(data);\r\n          updateRequest.onsuccess = () => resolve();\r\n          updateRequest.onerror = () => reject(updateRequest.error);\r\n        } else {\r\n          reject(new Error('Data not found'));\r\n        }\r\n      };\r\n      getRequest.onerror = () => reject(getRequest.error);\r\n    });\r\n  }\r\n\r\n  async deleteData(id: number): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const request = store.delete(id);\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  // Sync Queue Methods\r\n  async addToSyncQueue(item: Omit<SyncQueueItem, 'id' | 'timestamp' | 'retryCount'>): Promise<number> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const queueItem: SyncQueueItem = {\r\n        ...item,\r\n        timestamp: new Date().toISOString(),\r\n        retryCount: 0\r\n      };\r\n\r\n      const request = store.add(queueItem);\r\n      request.onsuccess = () => resolve(request.result as number);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async getSyncQueue(): Promise<SyncQueueItem[]> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readonly');\r\n      const store = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const request = store.getAll();\r\n      request.onsuccess = () => {\r\n        // Sort by priority and timestamp\r\n        const items = request.result.sort((a: SyncQueueItem, b: SyncQueueItem) => {\r\n          const priorityOrder: Record<string, number> = { high: 0, medium: 1, low: 2 };\r\n          const priorityDiff = (priorityOrder[a.priority] || 2) - (priorityOrder[b.priority] || 2);\r\n          if (priorityDiff !== 0) return priorityDiff;\r\n          return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();\r\n        });\r\n        resolve(items);\r\n      };\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async updateSyncQueueItem(id: number, updates: Partial<SyncQueueItem>): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const getRequest = store.get(id);\r\n      getRequest.onsuccess = () => {\r\n        const item = getRequest.result;\r\n        if (item) {\r\n          Object.assign(item, updates);\r\n          const updateRequest = store.put(item);\r\n          updateRequest.onsuccess = () => resolve();\r\n          updateRequest.onerror = () => reject(updateRequest.error);\r\n        } else {\r\n          reject(new Error('Sync queue item not found'));\r\n        }\r\n      };\r\n      getRequest.onerror = () => reject(getRequest.error);\r\n    });\r\n  }\r\n\r\n  async removeSyncQueueItem(id: number): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const request = store.delete(id);\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  // Utility Methods\r\n  async clearAllData(): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data, this.stores.syncQueue], 'readwrite');\r\n      let completed = 0;\r\n\r\n      const complete = () => {\r\n        completed++;\r\n        if (completed === 2) resolve();\r\n      };\r\n\r\n      const dataStore = transaction.objectStore(this.stores.data);\r\n      const syncStore = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const clearData = dataStore.clear();\r\n      const clearSync = syncStore.clear();\r\n\r\n      clearData.onsuccess = complete;\r\n      clearSync.onsuccess = complete;\r\n      clearData.onerror = () => reject(clearData.error);\r\n      clearSync.onerror = () => reject(clearSync.error);\r\n    });\r\n  }\r\n\r\n  async getStorageUsage(): Promise<{ used: number; quota: number }> {\r\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\r\n      const estimate = await navigator.storage.estimate();\r\n      return {\r\n        used: estimate.usage || 0,\r\n        quota: estimate.quota || 0\r\n      };\r\n    }\r\n    return { used: 0, quota: 0 };\r\n  }\r\n\r\n  async exportData(): Promise<{ data: StoredData[]; syncQueue: SyncQueueItem[] }> {\r\n    const [data, syncQueue] = await Promise.all([\r\n      this.getAllData(),\r\n      this.getSyncQueue()\r\n    ]);\r\n\r\n    return { data, syncQueue };\r\n  }\r\n\r\n  private async getAllData(): Promise<StoredData[]> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const request = store.getAll();\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async importData(data: StoredData[]): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      let completed = 0;\r\n      const total = data.length;\r\n\r\n      if (total === 0) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      const complete = () => {\r\n        completed++;\r\n        if (completed === total) resolve();\r\n      };\r\n\r\n      data.forEach(item => {\r\n        // Remove ID to let IndexedDB assign new ones\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        const { id: _id, ...itemWithoutId } = item;\r\n        const request = store.add(itemWithoutId);\r\n        request.onsuccess = complete;\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    });\r\n  }\r\n\r\n  // Singleton accessor\r\n  public static getInstance(): OfflineStorageService {\r\n    if (!this._instance) {\r\n      this._instance = new OfflineStorageService();\r\n    }\r\n    return this._instance;\r\n  }\r\n}\r\n\r\n// Export singleton instance via getInstance for backward compatibility\r\n// Provide a static getInstance on the class for other modules that call it\r\n// (some code imports OfflineStorageService and calls getInstance())\r\nexport const offlineStorage = OfflineStorageService.getInstance();\r\n\r\n// (namespace shim removed - class provides static getInstance)\r\n\r\n// Enhanced local storage with fallback to IndexedDB\r\nexport class EnhancedLocalStorage {\r\n  private static instance: EnhancedLocalStorage;\r\n  private storage: OfflineStorageService;\r\n\r\n  constructor() {\r\n    this.storage = offlineStorage;\r\n  }\r\n\r\n  static getInstance(): EnhancedLocalStorage {\r\n    if (!EnhancedLocalStorage.instance) {\r\n      EnhancedLocalStorage.instance = new EnhancedLocalStorage();\r\n    }\r\n    return EnhancedLocalStorage.instance;\r\n  }\r\n\r\n  async setItem(key: string, value: unknown): Promise<void> {\r\n    try {\r\n      // Try localStorage first\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n      \r\n      // Also store in IndexedDB as backup\r\n      await this.storage.storeData('settings', { key, value });\r\n    } catch (error) {\r\n      // Fallback to IndexedDB only\r\n      console.warn('localStorage failed, using IndexedDB:', error);\r\n      await this.storage.storeData('settings', { key, value });\r\n    }\r\n  }\r\n\r\n  async getItem(key: string): Promise<unknown> {\r\n    try {\r\n      // Try localStorage first\r\n      const item = localStorage.getItem(key);\r\n      if (item !== null) {\r\n        return JSON.parse(item);\r\n      }\r\n    } catch (error) {\r\n      console.warn('localStorage read failed:', error);\r\n    }\r\n\r\n    // Fallback to IndexedDB\r\n    try {\r\n      const settings = await this.storage.getData('settings');\r\n      const setting = settings.find(s => {\r\n        // Type guard to check if data has key property\r\n        return s.data && typeof s.data === 'object' && 'key' in s.data && s.data.key === key;\r\n      });\r\n      return setting && setting.data && typeof setting.data === 'object' && 'value' in setting.data \r\n        ? setting.data.value \r\n        : null;\r\n    } catch (error) {\r\n      console.error('IndexedDB read failed:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async removeItem(key: string): Promise<void> {\r\n    try {\r\n      localStorage.removeItem(key);\r\n    } catch (error) {\r\n      console.warn('localStorage removal failed:', error);\r\n    }\r\n\r\n    // Also remove from IndexedDB\r\n    try {\r\n      const settings = await this.storage.getData('settings');\r\n      const setting = settings.find(s => {\r\n        // Type guard to check if data has key property\r\n        return s.data && typeof s.data === 'object' && 'key' in s.data && s.data.key === key;\r\n      });\r\n      if (setting && setting.id) {\r\n        await this.storage.deleteData(setting.id);\r\n      }\r\n    } catch (error) {\r\n      console.error('IndexedDB removal failed:', error);\r\n    }\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    try {\r\n      localStorage.clear();\r\n    } catch (error) {\r\n      console.warn('localStorage clear failed:', error);\r\n    }\r\n\r\n    // Clear from IndexedDB - just clear all settings instead of filtering\r\n    try {\r\n      const settings = await this.storage.getData('settings');\r\n      await Promise.all(\r\n        settings\r\n          .filter(setting => setting.id !== undefined)\r\n          .map(setting => this.storage.deleteData(setting.id!))\r\n      );\r\n    } catch (error) {\r\n      console.error('IndexedDB clear failed:', error);\r\n    }\r\n  }\r\n}\r\n\r\nexport const enhancedStorage = EnhancedLocalStorage.getInstance();\r\n"],"names":["OfflineStorageService","resolve","reject","request","event","db","dataStore","syncStore","key","value","v","match","s","tableName","id","parts","settings","items","entry","parsed","deletions","item","keyToFind","type","data","store","storedData","getRequest","existing","updateRequest","queueItem","a","b","priorityOrder","priorityDiff","updates","transaction","completed","complete","clearData","clearSync","estimate","syncQueue","total","_id","itemWithoutId","offlineStorage"],"mappings":"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"}