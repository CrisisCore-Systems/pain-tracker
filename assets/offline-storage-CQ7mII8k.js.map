{"version":3,"file":"offline-storage-CQ7mII8k.js","sources":["../../src/lib/offline-storage.ts"],"sourcesContent":["/**\n * Offline Storage Service using IndexedDB\n * Provides robust data persistence for PWA offline functionality\n */\n\n// Define specific data types for better type safety\ntype PainEntryData = {\n  pain_level: number;\n  location: string;\n  description?: string;\n  triggers?: string[];\n  medications?: string[];\n  activities?: string[];\n  mood?: string;\n  weather?: string;\n  notes?: string;\n};\n\ntype EmergencyData = {\n  contactName: string;\n  phoneNumber: string;\n  relationship: string;\n  medicalInfo?: string;\n  allergies?: string[];\n  medications?: string[];\n};\n\ntype ActivityLogData = {\n  activity: string;\n  duration?: number;\n  intensity?: number;\n  painBefore?: number;\n  painAfter?: number;\n  notes?: string;\n};\n\ntype SettingsData =\n  | {\n      key: string;\n      value: unknown;\n    }\n  | {\n      [key: string]: unknown;\n    };\n\ntype SyncQueueData = {\n  operation: string;\n  payload: unknown;\n  priority: 'high' | 'medium' | 'low';\n};\n\ntype StoredDataPayload =\n  | PainEntryData\n  | EmergencyData\n  | ActivityLogData\n  | SettingsData\n  | SyncQueueData;\n\ninterface StoredData {\n  id?: number;\n  timestamp: string;\n  type: 'pain-entry' | 'emergency-data' | 'activity-log' | 'settings' | 'sync-queue';\n  data: StoredDataPayload;\n  synced?: boolean;\n  lastModified: string;\n}\n\ninterface SyncQueueItem {\n  id?: number;\n  url: string;\n  method: string;\n  headers: Record<string, string>;\n  body?: string;\n  timestamp: string;\n  priority: 'high' | 'medium' | 'low';\n  retryCount?: number;\n  type: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport class OfflineStorageService {\n  private dbName = 'pain-tracker-offline';\n  private dbVersion = 1;\n  private db: IDBDatabase | null = null;\n  private static _instance: OfflineStorageService | null = null;\n\n  // Store names\n  private stores = {\n    data: 'offline-data',\n    syncQueue: 'sync-queue',\n    cache: 'cache-metadata',\n  };\n\n  async init(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = event => {\n        const db = (event.target as IDBOpenDBRequest).result;\n\n        // Offline data store\n        if (!db.objectStoreNames.contains(this.stores.data)) {\n          const dataStore = db.createObjectStore(this.stores.data, {\n            keyPath: 'id',\n            autoIncrement: true,\n          });\n          dataStore.createIndex('type', 'type', { unique: false });\n          dataStore.createIndex('timestamp', 'timestamp', { unique: false });\n          dataStore.createIndex('synced', 'synced', { unique: false });\n        }\n\n        // Sync queue store\n        if (!db.objectStoreNames.contains(this.stores.syncQueue)) {\n          const syncStore = db.createObjectStore(this.stores.syncQueue, {\n            keyPath: 'id',\n            autoIncrement: true,\n          });\n          syncStore.createIndex('priority', 'priority', { unique: false });\n          syncStore.createIndex('timestamp', 'timestamp', { unique: false });\n          syncStore.createIndex('retryCount', 'retryCount', { unique: false });\n        }\n\n        // Cache metadata store\n        if (!db.objectStoreNames.contains(this.stores.cache)) {\n          const cacheStore = db.createObjectStore(this.stores.cache, {\n            keyPath: 'url',\n          });\n          cacheStore.createIndex('expiry', 'expiry', { unique: false });\n        }\n      };\n    });\n  }\n\n  // Key-value helpers (backed by EnhancedLocalStorage and IndexedDB settings)\n  async setItem(key: string, value: unknown): Promise<void> {\n    try {\n      // Store in localStorage for fast access and in IndexedDB for durability\n      localStorage.setItem(key, JSON.stringify(value));\n    } catch {\n      // ignore localStorage failures\n    }\n    await this.storeData('settings', { key, value });\n  }\n\n  async getItem<T = unknown>(key: string): Promise<T | null> {\n    try {\n      const v = localStorage.getItem(key);\n      if (v !== null) return JSON.parse(v) as T;\n    } catch {\n      // ignore\n    }\n    try {\n      const settings = await this.getData('settings');\n      const match = settings.find(\n        s =>\n          s.data &&\n          typeof s.data === 'object' &&\n          'key' in s.data &&\n          (s.data as Record<string, unknown>).key === key\n      );\n      if (match && match.data && typeof match.data === 'object' && 'value' in match.data) {\n        return (match.data as Record<string, unknown>).value as T;\n      }\n    } catch {\n      // ignore\n    }\n    return null;\n  }\n\n  // Table-like helpers implemented via settings key prefixes: table:{tableName}:{id}\n  private makeTableKey(tableName: string, id: string): string {\n    return `table:${tableName}:${id}`;\n  }\n\n  private parseTableKey(key: string): { table: string; id: string } | null {\n    if (!key.startsWith('table:')) return null;\n    const parts = key.split(':');\n    if (parts.length < 3) return null;\n    return { table: parts[1], id: parts.slice(2).join(':') };\n  }\n\n  async getAllFromTable<T = unknown>(tableName: string): Promise<T[]> {\n    const settings = await this.getData('settings');\n    const items: T[] = [];\n    for (const entry of settings) {\n      if (\n        entry.data &&\n        typeof entry.data === 'object' &&\n        'key' in entry.data &&\n        'value' in entry.data\n      ) {\n        const key = (entry.data as Record<string, unknown>).key as string;\n        const parsed = this.parseTableKey(key);\n        if (parsed && parsed.table === tableName) {\n          items.push((entry.data as Record<string, unknown>).value as T);\n        }\n      }\n    }\n    return items;\n  }\n\n  async replaceTable<T = unknown>(tableName: string, items: T[]): Promise<void> {\n    const settings = await this.getData('settings');\n    // Remove existing rows for table\n    const deletions: Promise<void>[] = [];\n    for (const entry of settings) {\n      if (\n        entry.id !== undefined &&\n        entry.data &&\n        typeof entry.data === 'object' &&\n        'key' in entry.data\n      ) {\n        const key = (entry.data as Record<string, unknown>).key as string;\n        const parsed = this.parseTableKey(key);\n        if (parsed && parsed.table === tableName) {\n          deletions.push(this.deleteData(entry.id));\n        }\n      }\n    }\n    await Promise.allSettled(deletions);\n    // Add new items\n    for (const item of items) {\n      const id = (item as unknown as { id?: string }).id || crypto.randomUUID();\n      await this.storeData('settings', {\n        key: this.makeTableKey(tableName, String(id)),\n        value: item,\n      });\n    }\n  }\n\n  async addToTable<T = unknown>(tableName: string, item: T & { id?: string }): Promise<void> {\n    const id = item.id || crypto.randomUUID();\n    await this.storeData('settings', {\n      key: this.makeTableKey(tableName, String(id)),\n      value: { ...item, id },\n    });\n  }\n\n  async updateInTable<T = unknown>(tableName: string, id: string | number, item: T): Promise<void> {\n    const settings = await this.getData('settings');\n    const keyToFind = this.makeTableKey(tableName, String(id));\n    const match = settings.find(\n      s =>\n        s.data &&\n        typeof s.data === 'object' &&\n        'key' in s.data &&\n        (s.data as Record<string, unknown>).key === keyToFind\n    );\n    if (match && match.id !== undefined) {\n      await this.updateData(match.id, { key: keyToFind, value: item });\n    } else {\n      // If not found, add\n      await this.storeData('settings', { key: keyToFind, value: item });\n    }\n  }\n\n  async removeFromTable(tableName: string, id: string | number): Promise<void> {\n    const settings = await this.getData('settings');\n    const keyToFind = this.makeTableKey(tableName, String(id));\n    const match = settings.find(\n      s =>\n        s.data &&\n        typeof s.data === 'object' &&\n        'key' in s.data &&\n        (s.data as Record<string, unknown>).key === keyToFind\n    );\n    if (match && match.id !== undefined) {\n      await this.deleteData(match.id);\n    }\n  }\n\n  async getFromTable<T = unknown>(tableName: string, id: string | number): Promise<T | null> {\n    const settings = await this.getData('settings');\n    const keyToFind = this.makeTableKey(tableName, String(id));\n    const match = settings.find(\n      s =>\n        s.data &&\n        typeof s.data === 'object' &&\n        'key' in s.data &&\n        (s.data as Record<string, unknown>).key === keyToFind\n    );\n    if (match && match.data && typeof match.data === 'object' && 'value' in match.data) {\n      return (match.data as Record<string, unknown>).value as T;\n    }\n    return null;\n  }\n\n  // Data Storage Methods\n  async storeData(type: StoredData['type'], data: StoredDataPayload): Promise<number> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\n      const store = transaction.objectStore(this.stores.data);\n\n      const storedData: StoredData = {\n        timestamp: new Date().toISOString(),\n        type,\n        data,\n        synced: false,\n        lastModified: new Date().toISOString(),\n      };\n\n      const request = store.add(storedData);\n      request.onsuccess = () => resolve(request.result as number);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async updateData(id: number, data: StoredDataPayload): Promise<void> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\n      const store = transaction.objectStore(this.stores.data);\n\n      const getRequest = store.get(id);\n      getRequest.onsuccess = () => {\n        const existing = getRequest.result;\n        if (existing) {\n          existing.data = data;\n          existing.lastModified = new Date().toISOString();\n          existing.synced = false;\n\n          const updateRequest = store.put(existing);\n          updateRequest.onsuccess = () => resolve();\n          updateRequest.onerror = () => reject(updateRequest.error);\n        } else {\n          reject(new Error('Data not found'));\n        }\n      };\n      getRequest.onerror = () => reject(getRequest.error);\n    });\n  }\n\n  async getData(type: StoredData['type']): Promise<StoredData[]> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\n      const store = transaction.objectStore(this.stores.data);\n      const index = store.index('type');\n\n      const request = index.getAll(type);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async getUnsyncedData(): Promise<StoredData[]> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\n      const store = transaction.objectStore(this.stores.data);\n      const index = store.index('synced');\n\n      const request = index.getAll(0); // Use 0 instead of false for unsynced items\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async markAsSynced(id: number): Promise<void> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\n      const store = transaction.objectStore(this.stores.data);\n\n      const getRequest = store.get(id);\n      getRequest.onsuccess = () => {\n        const data = getRequest.result;\n        if (data) {\n          data.synced = true;\n          const updateRequest = store.put(data);\n          updateRequest.onsuccess = () => resolve();\n          updateRequest.onerror = () => reject(updateRequest.error);\n        } else {\n          reject(new Error('Data not found'));\n        }\n      };\n      getRequest.onerror = () => reject(getRequest.error);\n    });\n  }\n\n  async deleteData(id: number): Promise<void> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\n      const store = transaction.objectStore(this.stores.data);\n\n      const request = store.delete(id);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // Sync Queue Methods\n  async addToSyncQueue(\n    item: Omit<SyncQueueItem, 'id' | 'timestamp' | 'retryCount'>\n  ): Promise<number> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\n      const store = transaction.objectStore(this.stores.syncQueue);\n\n      const queueItem: SyncQueueItem = {\n        ...item,\n        timestamp: new Date().toISOString(),\n        retryCount: 0,\n      };\n\n      const request = store.add(queueItem);\n      request.onsuccess = () => resolve(request.result as number);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async getSyncQueue(): Promise<SyncQueueItem[]> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readonly');\n      const store = transaction.objectStore(this.stores.syncQueue);\n\n      const request = store.getAll();\n      request.onsuccess = () => {\n        // Sort by priority and timestamp\n        const items = request.result.sort((a: SyncQueueItem, b: SyncQueueItem) => {\n          const priorityOrder: Record<string, number> = { high: 0, medium: 1, low: 2 };\n          const priorityDiff = (priorityOrder[a.priority] || 2) - (priorityOrder[b.priority] || 2);\n          if (priorityDiff !== 0) return priorityDiff;\n          return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();\n        });\n        resolve(items);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async updateSyncQueueItem(id: number, updates: Partial<SyncQueueItem>): Promise<void> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\n      const store = transaction.objectStore(this.stores.syncQueue);\n\n      const getRequest = store.get(id);\n      getRequest.onsuccess = () => {\n        const item = getRequest.result;\n        if (item) {\n          Object.assign(item, updates);\n          const updateRequest = store.put(item);\n          updateRequest.onsuccess = () => resolve();\n          updateRequest.onerror = () => reject(updateRequest.error);\n        } else {\n          reject(new Error('Sync queue item not found'));\n        }\n      };\n      getRequest.onerror = () => reject(getRequest.error);\n    });\n  }\n\n  async removeSyncQueueItem(id: number): Promise<void> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\n      const store = transaction.objectStore(this.stores.syncQueue);\n\n      const request = store.delete(id);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // Utility Methods\n  async clearAllData(): Promise<void> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction(\n        [this.stores.data, this.stores.syncQueue],\n        'readwrite'\n      );\n      let completed = 0;\n\n      const complete = () => {\n        completed++;\n        if (completed === 2) resolve();\n      };\n\n      const dataStore = transaction.objectStore(this.stores.data);\n      const syncStore = transaction.objectStore(this.stores.syncQueue);\n\n      const clearData = dataStore.clear();\n      const clearSync = syncStore.clear();\n\n      clearData.onsuccess = complete;\n      clearSync.onsuccess = complete;\n      clearData.onerror = () => reject(clearData.error);\n      clearSync.onerror = () => reject(clearSync.error);\n    });\n  }\n\n  async getStorageUsage(): Promise<{ used: number; quota: number }> {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      const estimate = await navigator.storage.estimate();\n      return {\n        used: estimate.usage || 0,\n        quota: estimate.quota || 0,\n      };\n    }\n    return { used: 0, quota: 0 };\n  }\n\n  async exportData(): Promise<{ data: StoredData[]; syncQueue: SyncQueueItem[] }> {\n    const [data, syncQueue] = await Promise.all([this.getAllData(), this.getSyncQueue()]);\n\n    return { data, syncQueue };\n  }\n\n  private async getAllData(): Promise<StoredData[]> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\n      const store = transaction.objectStore(this.stores.data);\n\n      const request = store.getAll();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async importData(data: StoredData[]): Promise<void> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\n      const store = transaction.objectStore(this.stores.data);\n\n      let completed = 0;\n      const total = data.length;\n\n      if (total === 0) {\n        resolve();\n        return;\n      }\n\n      const complete = () => {\n        completed++;\n        if (completed === total) resolve();\n      };\n\n      data.forEach(item => {\n        // Remove ID to let IndexedDB assign new ones\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { id: _id, ...itemWithoutId } = item;\n        const request = store.add(itemWithoutId);\n        request.onsuccess = complete;\n        request.onerror = () => reject(request.error);\n      });\n    });\n  }\n\n  // Singleton accessor\n  public static getInstance(): OfflineStorageService {\n    if (!this._instance) {\n      this._instance = new OfflineStorageService();\n    }\n    return this._instance;\n  }\n}\n\n// Export singleton instance via getInstance for backward compatibility\n// Provide a static getInstance on the class for other modules that call it\n// (some code imports OfflineStorageService and calls getInstance())\nexport const offlineStorage = OfflineStorageService.getInstance();\n\n// (namespace shim removed - class provides static getInstance)\n\n// Enhanced local storage with fallback to IndexedDB\nexport class EnhancedLocalStorage {\n  private static instance: EnhancedLocalStorage;\n  private storage: OfflineStorageService;\n\n  constructor() {\n    this.storage = offlineStorage;\n  }\n\n  static getInstance(): EnhancedLocalStorage {\n    if (!EnhancedLocalStorage.instance) {\n      EnhancedLocalStorage.instance = new EnhancedLocalStorage();\n    }\n    return EnhancedLocalStorage.instance;\n  }\n\n  async setItem(key: string, value: unknown): Promise<void> {\n    try {\n      // Try localStorage first\n      localStorage.setItem(key, JSON.stringify(value));\n\n      // Also store in IndexedDB as backup\n      await this.storage.storeData('settings', { key, value });\n    } catch (error) {\n      // Fallback to IndexedDB only\n      console.warn('localStorage failed, using IndexedDB:', error);\n      await this.storage.storeData('settings', { key, value });\n    }\n  }\n\n  async getItem(key: string): Promise<unknown> {\n    try {\n      // Try localStorage first\n      const item = localStorage.getItem(key);\n      if (item !== null) {\n        return JSON.parse(item);\n      }\n    } catch (error) {\n      console.warn('localStorage read failed:', error);\n    }\n\n    // Fallback to IndexedDB\n    try {\n      const settings = await this.storage.getData('settings');\n      const setting = settings.find(s => {\n        // Type guard to check if data has key property\n        return s.data && typeof s.data === 'object' && 'key' in s.data && s.data.key === key;\n      });\n      return setting && setting.data && typeof setting.data === 'object' && 'value' in setting.data\n        ? setting.data.value\n        : null;\n    } catch (error) {\n      console.error('IndexedDB read failed:', error);\n      return null;\n    }\n  }\n\n  async removeItem(key: string): Promise<void> {\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.warn('localStorage removal failed:', error);\n    }\n\n    // Also remove from IndexedDB\n    try {\n      const settings = await this.storage.getData('settings');\n      const setting = settings.find(s => {\n        // Type guard to check if data has key property\n        return s.data && typeof s.data === 'object' && 'key' in s.data && s.data.key === key;\n      });\n      if (setting && setting.id) {\n        await this.storage.deleteData(setting.id);\n      }\n    } catch (error) {\n      console.error('IndexedDB removal failed:', error);\n    }\n  }\n\n  async clear(): Promise<void> {\n    try {\n      localStorage.clear();\n    } catch (error) {\n      console.warn('localStorage clear failed:', error);\n    }\n\n    // Clear from IndexedDB - just clear all settings instead of filtering\n    try {\n      const settings = await this.storage.getData('settings');\n      await Promise.all(\n        settings\n          .filter(setting => setting.id !== undefined)\n          .map(setting => this.storage.deleteData(setting.id!))\n      );\n    } catch (error) {\n      console.error('IndexedDB clear failed:', error);\n    }\n  }\n}\n\nexport const enhancedStorage = EnhancedLocalStorage.getInstance();\n"],"names":["OfflineStorageService","resolve","reject","request","event","db","dataStore","syncStore","key","value","v","match","s","tableName","id","parts","settings","items","entry","parsed","deletions","item","keyToFind","type","data","store","storedData","getRequest","existing","updateRequest","queueItem","a","b","priorityOrder","priorityDiff","updates","transaction","completed","complete","clearData","clearSync","estimate","syncQueue","total","_id","itemWithoutId","offlineStorage"],"mappings":"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"}