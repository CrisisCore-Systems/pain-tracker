import{offlineStorage as r}from"./offline-storage-CQ7mII8k.js";import{s as a}from"./index-BuEiHtOO.js";import"./react-vendor-Bn1aEwkj.js";import"./chart-vendor-B7B0FrSV.js";import"./date-vendor-VbNwGsdS.js";class o{static instance;isOnline=navigator.onLine;syncInProgress=!1;retryTimeouts=new Map;maxRetries=3;retryDelays=[1e3,5e3,15e3];constructor(){this.setupEventListeners(),this.startPeriodicSync()}static getInstance(){return o.instance||(o.instance=new o),o.instance}setupEventListeners(){window.addEventListener("online",()=>{this.isOnline=!0,console.log("BackgroundSync: Connection restored, starting sync"),this.syncAllPendingData()}),window.addEventListener("offline",()=>{this.isOnline=!1,console.log("BackgroundSync: Connection lost")}),document.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&this.isOnline&&this.syncAllPendingData()}),window.addEventListener("pwa-online",()=>{this.isOnline=!0,this.syncAllPendingData()})}startPeriodicSync(){setInterval(()=>{this.isOnline&&!this.syncInProgress&&this.syncAllPendingData()},300*1e3)}async queueForSync(e,t,n,s="medium"){try{const c={"Content-Type":"application/json"},i=a.get("auth-token",{encrypt:!0});i&&(c.Authorization=`Bearer ${i}`),await r.addToSyncQueue({url:e,method:t.toUpperCase(),headers:c,body:n?JSON.stringify(n):void 0,priority:s,type:"api-request"}),console.log(`BackgroundSync: Queued ${t} ${e} for sync`),this.isOnline&&this.syncAllPendingData()}catch(c){throw console.error("BackgroundSync: Failed to queue item for sync:",c),c}}async syncAllPendingData(){if(this.syncInProgress)return console.log("BackgroundSync: Sync already in progress"),this.getEmptyStats();if(!this.isOnline)return console.log("BackgroundSync: Cannot sync while offline"),this.getEmptyStats();this.syncInProgress=!0,console.log("BackgroundSync: Starting sync process");const e={totalItems:0,successCount:0,failureCount:0,skippedCount:0,errors:[]};try{const t=await r.getSyncQueue();if(e.totalItems=t.length,t.length===0)return console.log("BackgroundSync: No items to sync"),e;console.log(`BackgroundSync: Found ${t.length} items to sync`);for(const n of t)try{const s=await this.syncItem(n);s.success?(e.successCount++,await r.removeSyncQueueItem(n.id),console.log(`BackgroundSync: Successfully synced ${n.method} ${n.url}`)):s.error&&((n.retryCount||0)>=this.maxRetries?(e.failureCount++,e.errors.push(`Max retries exceeded for ${n.url}: ${s.error}`),await r.removeSyncQueueItem(n.id),console.error(`BackgroundSync: Max retries exceeded for ${n.url}`)):(await this.scheduleRetry(n,s),e.skippedCount++))}catch(s){e.failureCount++,e.errors.push(`Sync error for ${n.url}: ${s}`),console.error(`BackgroundSync: Error syncing ${n.url}:`,s)}e.successCount>0&&await this.updateLocalStore(),console.log("BackgroundSync: Sync completed",e),this.dispatchSyncEvent("sync-completed",e)}catch(t){const n=t instanceof Error?t.message:String(t);console.error("BackgroundSync: Sync process failed:",t),e.errors.push(`Sync process failed: ${n}`),this.dispatchSyncEvent("sync-error",{error:n})}finally{this.syncInProgress=!1}return e}async syncItem(e){try{if(!this.isOnline)return{success:!1,itemId:e.id,error:"Offline"};const t=await fetch(e.url,{method:e.method,headers:e.headers,body:e.body});if(t.ok)return{success:!0,itemId:e.id};{let n=`HTTP ${t.status}`;try{n=(await t.json()).message||n}catch{n=t.statusText||n}const s=t.status>=500||t.status===429;return{success:!1,itemId:e.id,error:n,retryAfter:s?this.getRetryDelay(e.retryCount||0):void 0}}}catch(t){return{success:!1,itemId:e.id,error:t instanceof Error?t.message:"Network error"}}}async scheduleRetry(e,t){const n=t.retryAfter||this.getRetryDelay(e.retryCount||0);this.retryTimeouts.has(e.id)&&clearTimeout(this.retryTimeouts.get(e.id)),await r.updateSyncQueueItem(e.id,{retryCount:(e.retryCount||0)+1});const s=setTimeout(()=>{this.retryTimeouts.delete(e.id),this.syncAllPendingData()},n);this.retryTimeouts.set(e.id,s),console.log(`BackgroundSync: Scheduled retry for ${e.url} in ${n}ms`)}getRetryDelay(e){return e<this.retryDelays.length?this.retryDelays[e]:Math.min(3e4,this.retryDelays[this.retryDelays.length-1]*Math.pow(2,e-this.retryDelays.length))}async updateLocalStore(){try{const e=await r.getUnsyncedData();for(const t of e)t.type==="pain-entry"&&t.synced}catch(e){console.error("BackgroundSync: Failed to update local store:",e)}}getEmptyStats(){return{totalItems:0,successCount:0,failureCount:0,skippedCount:0,errors:[]}}dispatchSyncEvent(e,t){const n=new CustomEvent(`background-sync-${e}`,{detail:t});window.dispatchEvent(n)}async forcSync(){return console.log("BackgroundSync: Force sync requested"),this.syncAllPendingData()}async forceSync(){return this.forcSync()}async clearFailedItems(){try{const t=(await r.getSyncQueue()).filter(n=>(n.retryCount||0)>=this.maxRetries);await Promise.all(t.map(n=>r.removeSyncQueueItem(n.id))),console.log(`BackgroundSync: Cleared ${t.length} failed items`)}catch(e){console.error("BackgroundSync: Failed to clear failed items:",e)}}async getPendingItemsCount(){try{return(await r.getSyncQueue()).length}catch(e){return console.error("BackgroundSync: Failed to get pending items count:",e),0}}getSyncStatus(){return{isOnline:this.isOnline,isSyncing:this.syncInProgress}}async emergencySync(e,t){if(!this.isOnline)return await this.queueForSync(t,"POST",e,"high"),!1;try{return(await fetch(t,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${a.get("auth-token",{encrypt:!0})||""}`},body:JSON.stringify(e)})).ok?(console.log("BackgroundSync: Emergency sync successful"),!0):(await this.queueForSync(t,"POST",e,"high"),!1)}catch(n){return console.error("BackgroundSync: Emergency sync failed:",n),await this.queueForSync(t,"POST",e,"high"),!1}}}class y{backgroundSync;baseUrl;constructor(){this.backgroundSync=o.getInstance(),this.baseUrl="/api"}async syncPainEntry(e){const t=`${this.baseUrl}/pain-entries`;await this.backgroundSync.queueForSync(t,"POST",e,"high")}async syncPainEntryUpdate(e,t){const n=`${this.baseUrl}/pain-entries/${e}`;await this.backgroundSync.queueForSync(n,"PUT",t,"medium")}async syncEmergencyData(e){const t=`${this.baseUrl}/emergency`;return this.backgroundSync.emergencySync(e,t)}async syncActivityLog(e){const t=`${this.baseUrl}/activity-logs`;await this.backgroundSync.queueForSync(t,"POST",e,"low")}async syncSettings(e){const t=`${this.baseUrl}/settings`;await this.backgroundSync.queueForSync(t,"PUT",e,"low")}async getSyncStatus(){const t=(await r.getSyncQueue()).filter(i=>i.url.includes("/pain-entries")),n=a.get("last-sync-time"),{isOnline:s,isSyncing:c}=this.backgroundSync.getSyncStatus();return{pendingEntries:t.length,lastSync:n,isOnline:s,isSyncing:c}}async forceSync(){(await this.backgroundSync.forceSync()).successCount>0&&a.set("last-sync-time",new Date().toISOString())}}const f=o.getInstance(),p=new y;export{o as BackgroundSyncService,y as PainTrackerSync,f as backgroundSync,p as painTrackerSync};
//# sourceMappingURL=background-sync-XX6HOazI.js.map
