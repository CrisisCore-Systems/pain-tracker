{"version":3,"file":"offline-storage-BNc7x0M7.js","sources":["../../src/lib/offline-storage.ts"],"sourcesContent":["/**\r\n * Offline Storage Service using IndexedDB\r\n * Provides robust data persistence for PWA offline functionality\r\n */\r\n\r\n// Define specific data types for better type safety\r\ntype PainEntryData = {\r\n  pain_level: number;\r\n  location: string;\r\n  description?: string;\r\n  triggers?: string[];\r\n  medications?: string[];\r\n  activities?: string[];\r\n  mood?: string;\r\n  weather?: string;\r\n  notes?: string;\r\n};\r\n\r\ntype EmergencyData = {\r\n  contactName: string;\r\n  phoneNumber: string;\r\n  relationship: string;\r\n  medicalInfo?: string;\r\n  allergies?: string[];\r\n  medications?: string[];\r\n};\r\n\r\ntype ActivityLogData = {\r\n  activity: string;\r\n  duration?: number;\r\n  intensity?: number;\r\n  painBefore?: number;\r\n  painAfter?: number;\r\n  notes?: string;\r\n};\r\n\r\ntype SettingsData =\r\n  | {\r\n      key: string;\r\n      value: unknown;\r\n    }\r\n  | {\r\n      [key: string]: unknown;\r\n    };\r\n\r\ntype SyncQueueData = {\r\n  operation: string;\r\n  payload: unknown;\r\n  priority: 'high' | 'medium' | 'low';\r\n};\r\n\r\ntype StoredDataPayload =\r\n  | PainEntryData\r\n  | EmergencyData\r\n  | ActivityLogData\r\n  | SettingsData\r\n  | SyncQueueData;\r\n\r\ninterface StoredData {\r\n  id?: number;\r\n  timestamp: string;\r\n  type: 'pain-entry' | 'emergency-data' | 'activity-log' | 'settings' | 'sync-queue';\r\n  data: StoredDataPayload;\r\n  synced?: boolean;\r\n  lastModified: string;\r\n}\r\n\r\ninterface SyncQueueItem {\r\n  id?: number;\r\n  url: string;\r\n  method: string;\r\n  headers: Record<string, string>;\r\n  body?: string;\r\n  timestamp: string;\r\n  priority: 'high' | 'medium' | 'low';\r\n  retryCount?: number;\r\n  type: string;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\nexport class OfflineStorageService {\r\n  private dbName = 'pain-tracker-offline';\r\n  private dbVersion = 1;\r\n  private db: IDBDatabase | null = null;\r\n  private static _instance: OfflineStorageService | null = null;\r\n\r\n  // Store names\r\n  private stores = {\r\n    data: 'offline-data',\r\n    syncQueue: 'sync-queue',\r\n    cache: 'cache-metadata',\r\n  };\r\n\r\n  async init(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(this.dbName, this.dbVersion);\r\n\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => {\r\n        this.db = request.result;\r\n        resolve();\r\n      };\r\n\r\n      request.onupgradeneeded = event => {\r\n        const db = (event.target as IDBOpenDBRequest).result;\r\n\r\n        // Offline data store\r\n        if (!db.objectStoreNames.contains(this.stores.data)) {\r\n          const dataStore = db.createObjectStore(this.stores.data, {\r\n            keyPath: 'id',\r\n            autoIncrement: true,\r\n          });\r\n          dataStore.createIndex('type', 'type', { unique: false });\r\n          dataStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n          dataStore.createIndex('synced', 'synced', { unique: false });\r\n        }\r\n\r\n        // Sync queue store\r\n        if (!db.objectStoreNames.contains(this.stores.syncQueue)) {\r\n          const syncStore = db.createObjectStore(this.stores.syncQueue, {\r\n            keyPath: 'id',\r\n            autoIncrement: true,\r\n          });\r\n          syncStore.createIndex('priority', 'priority', { unique: false });\r\n          syncStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n          syncStore.createIndex('retryCount', 'retryCount', { unique: false });\r\n        }\r\n\r\n        // Cache metadata store\r\n        if (!db.objectStoreNames.contains(this.stores.cache)) {\r\n          const cacheStore = db.createObjectStore(this.stores.cache, {\r\n            keyPath: 'url',\r\n          });\r\n          cacheStore.createIndex('expiry', 'expiry', { unique: false });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  // Key-value helpers (backed by EnhancedLocalStorage and IndexedDB settings)\r\n  async setItem(key: string, value: unknown): Promise<void> {\r\n    try {\r\n      // Store in localStorage for fast access and in IndexedDB for durability\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n    } catch {\r\n      // ignore localStorage failures\r\n    }\r\n    await this.storeData('settings', { key, value });\r\n  }\r\n\r\n  async getItem<T = unknown>(key: string): Promise<T | null> {\r\n    try {\r\n      const v = localStorage.getItem(key);\r\n      if (v !== null) return JSON.parse(v) as T;\r\n    } catch {\r\n      // ignore\r\n    }\r\n    try {\r\n      const settings = await this.getData('settings');\r\n      const match = settings.find(\r\n        s =>\r\n          s.data &&\r\n          typeof s.data === 'object' &&\r\n          'key' in s.data &&\r\n          (s.data as Record<string, unknown>).key === key\r\n      );\r\n      if (match && match.data && typeof match.data === 'object' && 'value' in match.data) {\r\n        return (match.data as Record<string, unknown>).value as T;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Table-like helpers implemented via settings key prefixes: table:{tableName}:{id}\r\n  private makeTableKey(tableName: string, id: string): string {\r\n    return `table:${tableName}:${id}`;\r\n  }\r\n\r\n  private parseTableKey(key: string): { table: string; id: string } | null {\r\n    if (!key.startsWith('table:')) return null;\r\n    const parts = key.split(':');\r\n    if (parts.length < 3) return null;\r\n    return { table: parts[1], id: parts.slice(2).join(':') };\r\n  }\r\n\r\n  async getAllFromTable<T = unknown>(tableName: string): Promise<T[]> {\r\n    const settings = await this.getData('settings');\r\n    const items: T[] = [];\r\n    for (const entry of settings) {\r\n      if (\r\n        entry.data &&\r\n        typeof entry.data === 'object' &&\r\n        'key' in entry.data &&\r\n        'value' in entry.data\r\n      ) {\r\n        const key = (entry.data as Record<string, unknown>).key as string;\r\n        const parsed = this.parseTableKey(key);\r\n        if (parsed && parsed.table === tableName) {\r\n          items.push((entry.data as Record<string, unknown>).value as T);\r\n        }\r\n      }\r\n    }\r\n    return items;\r\n  }\r\n\r\n  async replaceTable<T = unknown>(tableName: string, items: T[]): Promise<void> {\r\n    const settings = await this.getData('settings');\r\n    // Remove existing rows for table\r\n    const deletions: Promise<void>[] = [];\r\n    for (const entry of settings) {\r\n      if (\r\n        entry.id !== undefined &&\r\n        entry.data &&\r\n        typeof entry.data === 'object' &&\r\n        'key' in entry.data\r\n      ) {\r\n        const key = (entry.data as Record<string, unknown>).key as string;\r\n        const parsed = this.parseTableKey(key);\r\n        if (parsed && parsed.table === tableName) {\r\n          deletions.push(this.deleteData(entry.id));\r\n        }\r\n      }\r\n    }\r\n    await Promise.allSettled(deletions);\r\n    // Add new items\r\n    for (const item of items) {\r\n      const id = (item as unknown as { id?: string }).id || crypto.randomUUID();\r\n      await this.storeData('settings', {\r\n        key: this.makeTableKey(tableName, String(id)),\r\n        value: item,\r\n      });\r\n    }\r\n  }\r\n\r\n  async addToTable<T = unknown>(tableName: string, item: T & { id?: string }): Promise<void> {\r\n    const id = item.id || crypto.randomUUID();\r\n    await this.storeData('settings', {\r\n      key: this.makeTableKey(tableName, String(id)),\r\n      value: { ...item, id },\r\n    });\r\n  }\r\n\r\n  async updateInTable<T = unknown>(tableName: string, id: string | number, item: T): Promise<void> {\r\n    const settings = await this.getData('settings');\r\n    const keyToFind = this.makeTableKey(tableName, String(id));\r\n    const match = settings.find(\r\n      s =>\r\n        s.data &&\r\n        typeof s.data === 'object' &&\r\n        'key' in s.data &&\r\n        (s.data as Record<string, unknown>).key === keyToFind\r\n    );\r\n    if (match && match.id !== undefined) {\r\n      await this.updateData(match.id, { key: keyToFind, value: item });\r\n    } else {\r\n      // If not found, add\r\n      await this.storeData('settings', { key: keyToFind, value: item });\r\n    }\r\n  }\r\n\r\n  async removeFromTable(tableName: string, id: string | number): Promise<void> {\r\n    const settings = await this.getData('settings');\r\n    const keyToFind = this.makeTableKey(tableName, String(id));\r\n    const match = settings.find(\r\n      s =>\r\n        s.data &&\r\n        typeof s.data === 'object' &&\r\n        'key' in s.data &&\r\n        (s.data as Record<string, unknown>).key === keyToFind\r\n    );\r\n    if (match && match.id !== undefined) {\r\n      await this.deleteData(match.id);\r\n    }\r\n  }\r\n\r\n  async getFromTable<T = unknown>(tableName: string, id: string | number): Promise<T | null> {\r\n    const settings = await this.getData('settings');\r\n    const keyToFind = this.makeTableKey(tableName, String(id));\r\n    const match = settings.find(\r\n      s =>\r\n        s.data &&\r\n        typeof s.data === 'object' &&\r\n        'key' in s.data &&\r\n        (s.data as Record<string, unknown>).key === keyToFind\r\n    );\r\n    if (match && match.data && typeof match.data === 'object' && 'value' in match.data) {\r\n      return (match.data as Record<string, unknown>).value as T;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Data Storage Methods\r\n  async storeData(type: StoredData['type'], data: StoredDataPayload): Promise<number> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const storedData: StoredData = {\r\n        timestamp: new Date().toISOString(),\r\n        type,\r\n        data,\r\n        synced: false,\r\n        lastModified: new Date().toISOString(),\r\n      };\r\n\r\n      const request = store.add(storedData);\r\n      request.onsuccess = () => resolve(request.result as number);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async updateData(id: number, data: StoredDataPayload): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const getRequest = store.get(id);\r\n      getRequest.onsuccess = () => {\r\n        const existing = getRequest.result;\r\n        if (existing) {\r\n          existing.data = data;\r\n          existing.lastModified = new Date().toISOString();\r\n          existing.synced = false;\r\n\r\n          const updateRequest = store.put(existing);\r\n          updateRequest.onsuccess = () => resolve();\r\n          updateRequest.onerror = () => reject(updateRequest.error);\r\n        } else {\r\n          reject(new Error('Data not found'));\r\n        }\r\n      };\r\n      getRequest.onerror = () => reject(getRequest.error);\r\n    });\r\n  }\r\n\r\n  async getData(type: StoredData['type']): Promise<StoredData[]> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\r\n      const store = transaction.objectStore(this.stores.data);\r\n      const index = store.index('type');\r\n\r\n      const request = index.getAll(type);\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async getUnsyncedData(): Promise<StoredData[]> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\r\n      const store = transaction.objectStore(this.stores.data);\r\n      const index = store.index('synced');\r\n\r\n      const request = index.getAll(0); // Use 0 instead of false for unsynced items\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async markAsSynced(id: number): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const getRequest = store.get(id);\r\n      getRequest.onsuccess = () => {\r\n        const data = getRequest.result;\r\n        if (data) {\r\n          data.synced = true;\r\n          const updateRequest = store.put(data);\r\n          updateRequest.onsuccess = () => resolve();\r\n          updateRequest.onerror = () => reject(updateRequest.error);\r\n        } else {\r\n          reject(new Error('Data not found'));\r\n        }\r\n      };\r\n      getRequest.onerror = () => reject(getRequest.error);\r\n    });\r\n  }\r\n\r\n  async deleteData(id: number): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const request = store.delete(id);\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  // Sync Queue Methods\r\n  async addToSyncQueue(\r\n    item: Omit<SyncQueueItem, 'id' | 'timestamp' | 'retryCount'>\r\n  ): Promise<number> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const queueItem: SyncQueueItem = {\r\n        ...item,\r\n        timestamp: new Date().toISOString(),\r\n        retryCount: 0,\r\n      };\r\n\r\n      const request = store.add(queueItem);\r\n      request.onsuccess = () => resolve(request.result as number);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async getSyncQueue(): Promise<SyncQueueItem[]> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readonly');\r\n      const store = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const request = store.getAll();\r\n      request.onsuccess = () => {\r\n        // Sort by priority and timestamp\r\n        const items = request.result.sort((a: SyncQueueItem, b: SyncQueueItem) => {\r\n          const priorityOrder: Record<string, number> = { high: 0, medium: 1, low: 2 };\r\n          const priorityDiff = (priorityOrder[a.priority] || 2) - (priorityOrder[b.priority] || 2);\r\n          if (priorityDiff !== 0) return priorityDiff;\r\n          return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();\r\n        });\r\n        resolve(items);\r\n      };\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async updateSyncQueueItem(id: number, updates: Partial<SyncQueueItem>): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const getRequest = store.get(id);\r\n      getRequest.onsuccess = () => {\r\n        const item = getRequest.result;\r\n        if (item) {\r\n          Object.assign(item, updates);\r\n          const updateRequest = store.put(item);\r\n          updateRequest.onsuccess = () => resolve();\r\n          updateRequest.onerror = () => reject(updateRequest.error);\r\n        } else {\r\n          reject(new Error('Sync queue item not found'));\r\n        }\r\n      };\r\n      getRequest.onerror = () => reject(getRequest.error);\r\n    });\r\n  }\r\n\r\n  async removeSyncQueueItem(id: number): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.syncQueue], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const request = store.delete(id);\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  // Utility Methods\r\n  async clearAllData(): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction(\r\n        [this.stores.data, this.stores.syncQueue],\r\n        'readwrite'\r\n      );\r\n      let completed = 0;\r\n\r\n      const complete = () => {\r\n        completed++;\r\n        if (completed === 2) resolve();\r\n      };\r\n\r\n      const dataStore = transaction.objectStore(this.stores.data);\r\n      const syncStore = transaction.objectStore(this.stores.syncQueue);\r\n\r\n      const clearData = dataStore.clear();\r\n      const clearSync = syncStore.clear();\r\n\r\n      clearData.onsuccess = complete;\r\n      clearSync.onsuccess = complete;\r\n      clearData.onerror = () => reject(clearData.error);\r\n      clearSync.onerror = () => reject(clearSync.error);\r\n    });\r\n  }\r\n\r\n  async getStorageUsage(): Promise<{ used: number; quota: number }> {\r\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\r\n      const estimate = await navigator.storage.estimate();\r\n      return {\r\n        used: estimate.usage || 0,\r\n        quota: estimate.quota || 0,\r\n      };\r\n    }\r\n    return { used: 0, quota: 0 };\r\n  }\r\n\r\n  async exportData(): Promise<{ data: StoredData[]; syncQueue: SyncQueueItem[] }> {\r\n    const [data, syncQueue] = await Promise.all([this.getAllData(), this.getSyncQueue()]);\r\n\r\n    return { data, syncQueue };\r\n  }\r\n\r\n  private async getAllData(): Promise<StoredData[]> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readonly');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      const request = store.getAll();\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async importData(data: StoredData[]): Promise<void> {\r\n    if (!this.db) await this.init();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.stores.data], 'readwrite');\r\n      const store = transaction.objectStore(this.stores.data);\r\n\r\n      let completed = 0;\r\n      const total = data.length;\r\n\r\n      if (total === 0) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      const complete = () => {\r\n        completed++;\r\n        if (completed === total) resolve();\r\n      };\r\n\r\n      data.forEach(item => {\r\n        // Remove ID to let IndexedDB assign new ones\r\n        const { id: _id, ...itemWithoutId } = item;\r\n        const request = store.add(itemWithoutId);\r\n        request.onsuccess = complete;\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    });\r\n  }\r\n\r\n  // Singleton accessor\r\n  public static getInstance(): OfflineStorageService {\r\n    if (!this._instance) {\r\n      this._instance = new OfflineStorageService();\r\n    }\r\n    return this._instance;\r\n  }\r\n}\r\n\r\n// Export singleton instance via getInstance for backward compatibility\r\n// Provide a static getInstance on the class for other modules that call it\r\n// (some code imports OfflineStorageService and calls getInstance())\r\nexport const offlineStorage = OfflineStorageService.getInstance();\r\n\r\n// (namespace shim removed - class provides static getInstance)\r\n\r\n// Enhanced local storage with fallback to IndexedDB\r\nexport class EnhancedLocalStorage {\r\n  private static instance: EnhancedLocalStorage;\r\n  private storage: OfflineStorageService;\r\n\r\n  constructor() {\r\n    this.storage = offlineStorage;\r\n  }\r\n\r\n  static getInstance(): EnhancedLocalStorage {\r\n    if (!EnhancedLocalStorage.instance) {\r\n      EnhancedLocalStorage.instance = new EnhancedLocalStorage();\r\n    }\r\n    return EnhancedLocalStorage.instance;\r\n  }\r\n\r\n  async setItem(key: string, value: unknown): Promise<void> {\r\n    try {\r\n      // Try localStorage first\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n\r\n      // Also store in IndexedDB as backup\r\n      await this.storage.storeData('settings', { key, value });\r\n    } catch (error) {\r\n      // Fallback to IndexedDB only\r\n      console.warn('localStorage failed, using IndexedDB:', error);\r\n      await this.storage.storeData('settings', { key, value });\r\n    }\r\n  }\r\n\r\n  async getItem(key: string): Promise<unknown> {\r\n    try {\r\n      // Try localStorage first\r\n      const item = localStorage.getItem(key);\r\n      if (item !== null) {\r\n        return JSON.parse(item);\r\n      }\r\n    } catch (error) {\r\n      console.warn('localStorage read failed:', error);\r\n    }\r\n\r\n    // Fallback to IndexedDB\r\n    try {\r\n      const settings = await this.storage.getData('settings');\r\n      const setting = settings.find(s => {\r\n        // Type guard to check if data has key property\r\n        return s.data && typeof s.data === 'object' && 'key' in s.data && s.data.key === key;\r\n      });\r\n      return setting && setting.data && typeof setting.data === 'object' && 'value' in setting.data\r\n        ? setting.data.value\r\n        : null;\r\n    } catch (error) {\r\n      console.error('IndexedDB read failed:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async removeItem(key: string): Promise<void> {\r\n    try {\r\n      localStorage.removeItem(key);\r\n    } catch (error) {\r\n      console.warn('localStorage removal failed:', error);\r\n    }\r\n\r\n    // Also remove from IndexedDB\r\n    try {\r\n      const settings = await this.storage.getData('settings');\r\n      const setting = settings.find(s => {\r\n        // Type guard to check if data has key property\r\n        return s.data && typeof s.data === 'object' && 'key' in s.data && s.data.key === key;\r\n      });\r\n      if (setting && setting.id) {\r\n        await this.storage.deleteData(setting.id);\r\n      }\r\n    } catch (error) {\r\n      console.error('IndexedDB removal failed:', error);\r\n    }\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    try {\r\n      localStorage.clear();\r\n    } catch (error) {\r\n      console.warn('localStorage clear failed:', error);\r\n    }\r\n\r\n    // Clear from IndexedDB - just clear all settings instead of filtering\r\n    try {\r\n      const settings = await this.storage.getData('settings');\r\n      await Promise.all(\r\n        settings\r\n          .filter(setting => setting.id !== undefined)\r\n          .map(setting => this.storage.deleteData(setting.id!))\r\n      );\r\n    } catch (error) {\r\n      console.error('IndexedDB clear failed:', error);\r\n    }\r\n  }\r\n}\r\n\r\nexport const enhancedStorage = EnhancedLocalStorage.getInstance();\r\n"],"names":["OfflineStorageService","dbName","dbVersion","db","static","stores","data","syncQueue","cache","init","Promise","resolve","reject","request","indexedDB","open","this","onerror","error","onsuccess","result","onupgradeneeded","event","target","objectStoreNames","contains","dataStore","createObjectStore","keyPath","autoIncrement","createIndex","unique","syncStore","setItem","key","value","localStorage","JSON","stringify","storeData","getItem","v","parse","match","getData","find","s","makeTableKey","tableName","id","parseTableKey","startsWith","parts","split","length","table","slice","join","getAllFromTable","settings","items","entry","parsed","push","replaceTable","deletions","deleteData","allSettled","item","crypto","randomUUID","String","addToTable","updateInTable","keyToFind","updateData","removeFromTable","getFromTable","type","store","transaction","objectStore","storedData","timestamp","Date","toISOString","synced","lastModified","add","getRequest","get","existing","updateRequest","put","Error","index","getAll","getUnsyncedData","markAsSynced","delete","addToSyncQueue","queueItem","retryCount","getSyncQueue","sort","a","b","priorityOrder","high","medium","low","priorityDiff","priority","getTime","updateSyncQueueItem","updates","Object","assign","removeSyncQueueItem","clearAllData","completed","complete","clearData","clear","clearSync","getStorageUsage","navigator","storage","estimate","used","usage","quota","exportData","all","getAllData","importData","total","forEach","_id","itemWithoutId","getInstance","_instance","offlineStorage"],"mappings":"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"}