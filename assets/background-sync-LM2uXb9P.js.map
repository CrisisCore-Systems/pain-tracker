{"version":3,"file":"background-sync-LM2uXb9P.js","sources":["../../src/lib/background-sync.ts"],"sourcesContent":["/**\r\n * Background Sync Service\r\n * Handles synchronization of offline data when connection is restored\r\n */\r\n\r\nimport { offlineStorage } from './offline-storage';\r\nimport { secureStorage } from './storage/secureStorage';\r\n\r\ninterface SyncResult {\r\n  success: boolean;\r\n  itemId: number;\r\n  error?: string;\r\n  retryAfter?: number;\r\n}\r\n\r\ninterface SyncStats {\r\n  totalItems: number;\r\n  successCount: number;\r\n  failureCount: number;\r\n  skippedCount: number;\r\n  errors: string[];\r\n}\r\n\r\n// Shape of items stored in the sync queue (mirrors offlineStorage SyncQueueItem)\r\ninterface SyncQueueItemShape {\r\n  id?: number;\r\n  url: string;\r\n  method: string;\r\n  headers: Record<string, string>;\r\n  body?: string;\r\n  timestamp?: string;\r\n  priority: 'high' | 'medium' | 'low';\r\n  retryCount?: number;\r\n  type: string;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n// Payload convenience types for public API methods\r\ntype GenericRecord = Record<string, unknown>;\r\ntype QueuePayload = GenericRecord | FormData | string | number | boolean | null | undefined;\r\n\r\nexport class BackgroundSyncService {\r\n  private static instance: BackgroundSyncService;\r\n  private isOnline: boolean = navigator.onLine;\r\n  private syncInProgress: boolean = false;\r\n  private retryTimeouts: Map<number, NodeJS.Timeout> = new Map();\r\n  private maxRetries: number = 3;\r\n  private retryDelays: number[] = [1000, 5000, 15000]; // Progressive delays in ms\r\n\r\n  private constructor() {\r\n    this.setupEventListeners();\r\n    this.startPeriodicSync();\r\n  }\r\n\r\n  static getInstance(): BackgroundSyncService {\r\n    if (!BackgroundSyncService.instance) {\r\n      BackgroundSyncService.instance = new BackgroundSyncService();\r\n    }\r\n    return BackgroundSyncService.instance;\r\n  }\r\n\r\n  private setupEventListeners(): void {\r\n    // Listen for online/offline events\r\n    window.addEventListener('online', () => {\r\n      this.isOnline = true;\r\n      console.log('BackgroundSync: Connection restored, starting sync');\r\n      this.syncAllPendingData();\r\n    });\r\n\r\n    window.addEventListener('offline', () => {\r\n      this.isOnline = false;\r\n      console.log('BackgroundSync: Connection lost');\r\n    });\r\n\r\n    // Listen for visibility change to sync when app becomes active\r\n    document.addEventListener('visibilitychange', () => {\r\n      if (document.visibilityState === 'visible' && this.isOnline) {\r\n        this.syncAllPendingData();\r\n      }\r\n    });\r\n\r\n    // Listen for PWA events\r\n    window.addEventListener('pwa-online', () => {\r\n      this.isOnline = true;\r\n      this.syncAllPendingData();\r\n    });\r\n  }\r\n\r\n  private startPeriodicSync(): void {\r\n    // Sync every 5 minutes when online\r\n    setInterval(() => {\r\n      if (this.isOnline && !this.syncInProgress) {\r\n        this.syncAllPendingData();\r\n      }\r\n    }, 5 * 60 * 1000);\r\n  }\r\n\r\n  async queueForSync(\r\n    url: string,\r\n    method: string,\r\n    data?: QueuePayload,\r\n    priority: 'high' | 'medium' | 'low' = 'medium'\r\n  ): Promise<void> {\r\n    try {\r\n      const headers: Record<string, string> = {\r\n        'Content-Type': 'application/json'\r\n      };\r\n\r\n      // Add authentication headers if available\r\n  const token = secureStorage.get<string>('auth-token', { encrypt: true });\r\n      if (token) {\r\n        headers['Authorization'] = `Bearer ${token}`;\r\n      }\r\n\r\n      await offlineStorage.addToSyncQueue({\r\n        url,\r\n        method: method.toUpperCase(),\r\n        headers,\r\n        body: data ? JSON.stringify(data) : undefined,\r\n        priority,\r\n        type: 'api-request'\r\n      });\r\n\r\n      console.log(`BackgroundSync: Queued ${method} ${url} for sync`);\r\n\r\n      // Try to sync immediately if online\r\n      if (this.isOnline) {\r\n        this.syncAllPendingData();\r\n      }\r\n    } catch (error) {\r\n      console.error('BackgroundSync: Failed to queue item for sync:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async syncAllPendingData(): Promise<SyncStats> {\r\n    if (this.syncInProgress) {\r\n      console.log('BackgroundSync: Sync already in progress');\r\n      return this.getEmptyStats();\r\n    }\r\n\r\n    if (!this.isOnline) {\r\n      console.log('BackgroundSync: Cannot sync while offline');\r\n      return this.getEmptyStats();\r\n    }\r\n\r\n    this.syncInProgress = true;\r\n    console.log('BackgroundSync: Starting sync process');\r\n\r\n    const stats: SyncStats = {\r\n      totalItems: 0,\r\n      successCount: 0,\r\n      failureCount: 0,\r\n      skippedCount: 0,\r\n      errors: []\r\n    };\r\n\r\n    try {\r\n      // Get all pending sync items\r\n      const syncQueue = await offlineStorage.getSyncQueue();\r\n      stats.totalItems = syncQueue.length;\r\n\r\n      if (syncQueue.length === 0) {\r\n        console.log('BackgroundSync: No items to sync');\r\n        return stats;\r\n      }\r\n\r\n      console.log(`BackgroundSync: Found ${syncQueue.length} items to sync`);\r\n\r\n      // Process each item\r\n      for (const item of syncQueue) {\r\n        try {\r\n          const result = await this.syncItem(item);\r\n          \r\n          if (result.success) {\r\n            stats.successCount++;\r\n            await offlineStorage.removeSyncQueueItem(item.id!);\r\n            console.log(`BackgroundSync: Successfully synced ${item.method} ${item.url}`);\r\n          } else if (result.error) {\r\n            if ((item.retryCount || 0) >= this.maxRetries) {\r\n              stats.failureCount++;\r\n              stats.errors.push(`Max retries exceeded for ${item.url}: ${result.error}`);\r\n              await offlineStorage.removeSyncQueueItem(item.id!);\r\n              console.error(`BackgroundSync: Max retries exceeded for ${item.url}`);\r\n            } else {\r\n              // Schedule retry\r\n              await this.scheduleRetry(item, result);\r\n              stats.skippedCount++;\r\n            }\r\n          }\r\n        } catch (error) {\r\n          stats.failureCount++;\r\n          stats.errors.push(`Sync error for ${item.url}: ${error}`);\r\n          console.error(`BackgroundSync: Error syncing ${item.url}:`, error);\r\n        }\r\n      }\r\n\r\n      // Update local store if we synced pain entries\r\n      if (stats.successCount > 0) {\r\n        await this.updateLocalStore();\r\n      }\r\n\r\n      console.log('BackgroundSync: Sync completed', stats);\r\n      this.dispatchSyncEvent('sync-completed', stats);\r\n\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : String(error);\r\n      console.error('BackgroundSync: Sync process failed:', error);\r\n      stats.errors.push(`Sync process failed: ${errorMessage}`);\r\n      this.dispatchSyncEvent('sync-error', { error: errorMessage });\r\n    } finally {\r\n      this.syncInProgress = false;\r\n    }\r\n\r\n    return stats;\r\n  }\r\n\r\n  private async syncItem(item: SyncQueueItemShape): Promise<SyncResult> {\r\n    try {\r\n      // Check if we're still online\r\n      if (!this.isOnline) {\r\n        return { success: false, itemId: item.id!, error: 'Offline' };\r\n      }\r\n\r\n      const response = await fetch(item.url, {\r\n        method: item.method,\r\n        headers: item.headers,\r\n        body: item.body\r\n      });\r\n\r\n      if (response.ok) {\r\n        return { success: true, itemId: item.id! };\r\n      } else {\r\n        let errorMessage = `HTTP ${response.status}`;\r\n        \r\n        try {\r\n          const errorData = await response.json();\r\n          errorMessage = errorData.message || errorMessage;\r\n        } catch {\r\n          errorMessage = response.statusText || errorMessage;\r\n        }\r\n\r\n        // Determine if we should retry based on status code\r\n        const shouldRetry = response.status >= 500 || response.status === 429;\r\n        \r\n        return {\r\n          success: false,\r\n          itemId: item.id!,\r\n          error: errorMessage,\r\n          retryAfter: shouldRetry ? this.getRetryDelay(item.retryCount || 0) : undefined\r\n        };\r\n      }\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        itemId: item.id!,\r\n        error: error instanceof Error ? error.message : 'Network error'\r\n      };\r\n    }\r\n  }\r\n\r\n  private async scheduleRetry(item: SyncQueueItemShape, result: SyncResult): Promise<void> {\r\n    const delay = result.retryAfter || this.getRetryDelay(item.retryCount || 0);\r\n    \r\n    // Clear existing timeout for this item\r\n    if (this.retryTimeouts.has(item.id!)) {\r\n      clearTimeout(this.retryTimeouts.get(item.id!)!);\r\n    }\r\n\r\n    // Update retry count\r\n    await offlineStorage.updateSyncQueueItem(item.id!, {\r\n      retryCount: (item.retryCount || 0) + 1\r\n    });\r\n\r\n    // Schedule retry\r\n    const timeout = setTimeout(() => {\r\n      this.retryTimeouts.delete(item.id!);\r\n      this.syncAllPendingData();\r\n    }, delay);\r\n\r\n    this.retryTimeouts.set(item.id!, timeout);\r\n    \r\n    console.log(`BackgroundSync: Scheduled retry for ${item.url} in ${delay}ms`);\r\n  }\r\n\r\n  private getRetryDelay(retryCount: number): number {\r\n    if (retryCount < this.retryDelays.length) {\r\n      return this.retryDelays[retryCount];\r\n    }\r\n    // Exponential backoff for higher retry counts\r\n    return Math.min(30000, this.retryDelays[this.retryDelays.length - 1] * Math.pow(2, retryCount - this.retryDelays.length));\r\n  }\r\n\r\n  private async updateLocalStore(): Promise<void> {\r\n    try {\r\n      // Get all unsynced data\r\n      const unsyncedData = await offlineStorage.getUnsyncedData();\r\n      \r\n      // Update Zustand store with synced data\r\n      for (const item of unsyncedData) {\r\n        if (item.type === 'pain-entry' && item.synced) {\r\n          // Update the entry in the store to reflect sync status\r\n          // This could include updating a 'synced' flag or handling conflicts\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('BackgroundSync: Failed to update local store:', error);\r\n    }\r\n  }\r\n\r\n  private getEmptyStats(): SyncStats {\r\n    return {\r\n      totalItems: 0,\r\n      successCount: 0,\r\n      failureCount: 0,\r\n      skippedCount: 0,\r\n      errors: []\r\n    };\r\n  }\r\n\r\n  private dispatchSyncEvent(type: string, detail: unknown): void {\r\n    const event = new CustomEvent(`background-sync-${type}`, { detail });\r\n    window.dispatchEvent(event);\r\n  }\r\n\r\n  // Public methods for managing sync\r\n  async forcSync(): Promise<SyncStats> {\r\n  // cspell:ignore forc\r\n    console.log('BackgroundSync: Force sync requested');\r\n    return this.syncAllPendingData();\r\n  }\r\n\r\n  // Backwards-compatible correctly spelled alias - prefer this going forward\r\n  async forceSync(): Promise<SyncStats> {\r\n    return this.forcSync();\r\n  }\r\n\r\n  async clearFailedItems(): Promise<void> {\r\n    try {\r\n      const syncQueue = await offlineStorage.getSyncQueue();\r\n      const failedItems = syncQueue.filter(item => (item.retryCount || 0) >= this.maxRetries);\r\n      \r\n      await Promise.all(\r\n        failedItems.map(item => offlineStorage.removeSyncQueueItem(item.id!))\r\n      );\r\n      \r\n      console.log(`BackgroundSync: Cleared ${failedItems.length} failed items`);\r\n    } catch (error) {\r\n      console.error('BackgroundSync: Failed to clear failed items:', error);\r\n    }\r\n  }\r\n\r\n  async getPendingItemsCount(): Promise<number> {\r\n    try {\r\n      const syncQueue = await offlineStorage.getSyncQueue();\r\n      return syncQueue.length;\r\n    } catch (error) {\r\n      console.error('BackgroundSync: Failed to get pending items count:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  getSyncStatus(): { isOnline: boolean; isSyncing: boolean } {\r\n    return {\r\n      isOnline: this.isOnline,\r\n      isSyncing: this.syncInProgress\r\n    };\r\n  }\r\n\r\n  // Emergency sync for critical data\r\n  async emergencySync(data: QueuePayload, endpoint: string): Promise<boolean> {\r\n    if (!this.isOnline) {\r\n      await this.queueForSync(endpoint, 'POST', data, 'high');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(endpoint, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${secureStorage.get<string>('auth-token', { encrypt: true }) || ''}`\r\n        },\r\n        body: JSON.stringify(data)\r\n      });\r\n\r\n      if (response.ok) {\r\n        console.log('BackgroundSync: Emergency sync successful');\r\n        return true;\r\n      } else {\r\n        // Queue for retry even if it failed\r\n        await this.queueForSync(endpoint, 'POST', data, 'high');\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('BackgroundSync: Emergency sync failed:', error);\r\n      await this.queueForSync(endpoint, 'POST', data, 'high');\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// Background sync helper for pain tracker specific operations\r\nexport class PainTrackerSync {\r\n  private backgroundSync: BackgroundSyncService;\r\n  private baseUrl: string;\r\n\r\n  constructor() {\r\n    this.backgroundSync = BackgroundSyncService.getInstance();\r\n    this.baseUrl = import.meta.env.VITE_API_BASE_URL || '/api';\r\n  }\r\n\r\n  async syncPainEntry(entry: QueuePayload): Promise<void> {\r\n    const endpoint = `${this.baseUrl}/pain-entries`;\r\n    await this.backgroundSync.queueForSync(endpoint, 'POST', entry, 'high');\r\n  }\r\n\r\n  async syncPainEntryUpdate(id: number, updates: QueuePayload): Promise<void> {\r\n    const endpoint = `${this.baseUrl}/pain-entries/${id}`;\r\n    await this.backgroundSync.queueForSync(endpoint, 'PUT', updates, 'medium');\r\n  }\r\n\r\n  async syncEmergencyData(data: QueuePayload): Promise<boolean> {\r\n    const endpoint = `${this.baseUrl}/emergency`;\r\n    return this.backgroundSync.emergencySync(data, endpoint);\r\n  }\r\n\r\n  async syncActivityLog(log: QueuePayload): Promise<void> {\r\n    const endpoint = `${this.baseUrl}/activity-logs`;\r\n    await this.backgroundSync.queueForSync(endpoint, 'POST', log, 'low');\r\n  }\r\n\r\n  async syncSettings(settings: QueuePayload): Promise<void> {\r\n    const endpoint = `${this.baseUrl}/settings`;\r\n    await this.backgroundSync.queueForSync(endpoint, 'PUT', settings, 'low');\r\n  }\r\n\r\n  // Get sync status specifically for pain tracker data\r\n  async getSyncStatus(): Promise<{\r\n    pendingEntries: number;\r\n    lastSync: string | null;\r\n    isOnline: boolean;\r\n    isSyncing: boolean;\r\n  }> {\r\n    const syncQueue = await offlineStorage.getSyncQueue();\r\n    const painEntryQueue = syncQueue.filter(item => \r\n      item.url.includes('/pain-entries')\r\n    );\r\n\r\n  const lastSyncTime = secureStorage.get<string>('last-sync-time');\r\n    const { isOnline, isSyncing } = this.backgroundSync.getSyncStatus();\r\n\r\n    return {\r\n      pendingEntries: painEntryQueue.length,\r\n      lastSync: lastSyncTime,\r\n      isOnline,\r\n      isSyncing\r\n    };\r\n  }\r\n\r\n  async forceSync(): Promise<void> {\r\n    const stats = await this.backgroundSync.forceSync();\r\n    \r\n    if (stats.successCount > 0) {\r\n  secureStorage.set('last-sync-time', new Date().toISOString());\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instances\r\nexport const backgroundSync = BackgroundSyncService.getInstance();\r\nexport const painTrackerSync = new PainTrackerSync();\r\n"],"names":["BackgroundSyncService","url","method","data","priority","headers","token","secureStorage","offlineStorage","error","stats","syncQueue","item","result","errorMessage","response","shouldRetry","delay","timeout","retryCount","unsyncedData","type","detail","event","failedItems","endpoint","PainTrackerSync","entry","id","updates","log","settings","painEntryQueue","lastSyncTime","isOnline","isSyncing","backgroundSync","painTrackerSync"],"mappings":"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"}