class t{dbName="pain-tracker-offline";dbVersion=1;db=null;static _instance=null;stores={data:"offline-data",syncQueue:"sync-queue",cache:"cache-metadata"};async init(){return new Promise((t,e)=>{const s=indexedDB.open(this.dbName,this.dbVersion);s.onerror=()=>e(s.error),s.onsuccess=()=>{this.db=s.result,t()},s.onupgradeneeded=t=>{const e=t.target.result;if(!e.objectStoreNames.contains(this.stores.data)){const t=e.createObjectStore(this.stores.data,{keyPath:"id",autoIncrement:!0});t.createIndex("type","type",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("synced","synced",{unique:!1})}if(!e.objectStoreNames.contains(this.stores.syncQueue)){const t=e.createObjectStore(this.stores.syncQueue,{keyPath:"id",autoIncrement:!0});t.createIndex("priority","priority",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("retryCount","retryCount",{unique:!1})}if(!e.objectStoreNames.contains(this.stores.cache)){e.createObjectStore(this.stores.cache,{keyPath:"url"}).createIndex("expiry","expiry",{unique:!1})}}})}async setItem(t,e){try{localStorage.setItem(t,JSON.stringify(e))}catch{}await this.storeData("settings",{key:t,value:e})}async getItem(t){try{const e=localStorage.getItem(t);if(null!==e)return JSON.parse(e)}catch{}try{const e=(await this.getData("settings")).find(e=>e.data&&"object"==typeof e.data&&"key"in e.data&&e.data.key===t);if(e&&e.data&&"object"==typeof e.data&&"value"in e.data)return e.data.value}catch{}return null}makeTableKey(t,e){return`table:${t}:${e}`}parseTableKey(t){if(!t.startsWith("table:"))return null;const e=t.split(":");return e.length<3?null:{table:e[1],id:e.slice(2).join(":")}}async getAllFromTable(t){const e=await this.getData("settings"),s=[];for(const a of e)if(a.data&&"object"==typeof a.data&&"key"in a.data&&"value"in a.data){const e=a.data.key,r=this.parseTableKey(e);r&&r.table===t&&s.push(a.data.value)}return s}async replaceTable(t,e){const s=await this.getData("settings"),a=[];for(const r of s)if(void 0!==r.id&&r.data&&"object"==typeof r.data&&"key"in r.data){const e=r.data.key,s=this.parseTableKey(e);s&&s.table===t&&a.push(this.deleteData(r.id))}await Promise.allSettled(a);for(const r of e){const e=r.id||crypto.randomUUID();await this.storeData("settings",{key:this.makeTableKey(t,String(e)),value:r})}}async addToTable(t,e){const s=e.id||crypto.randomUUID();await this.storeData("settings",{key:this.makeTableKey(t,String(s)),value:{...e,id:s}})}async updateInTable(t,e,s){const a=await this.getData("settings"),r=this.makeTableKey(t,String(e)),n=a.find(t=>t.data&&"object"==typeof t.data&&"key"in t.data&&t.data.key===r);n&&void 0!==n.id?await this.updateData(n.id,{key:r,value:s}):await this.storeData("settings",{key:r,value:s})}async removeFromTable(t,e){const s=await this.getData("settings"),a=this.makeTableKey(t,String(e)),r=s.find(t=>t.data&&"object"==typeof t.data&&"key"in t.data&&t.data.key===a);r&&void 0!==r.id&&await this.deleteData(r.id)}async getFromTable(t,e){const s=await this.getData("settings"),a=this.makeTableKey(t,String(e)),r=s.find(t=>t.data&&"object"==typeof t.data&&"key"in t.data&&t.data.key===a);return r&&r.data&&"object"==typeof r.data&&"value"in r.data?r.data.value:null}async storeData(t,e){return this.db||await this.init(),new Promise((s,a)=>{const r=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data),n={timestamp:(new Date).toISOString(),type:t,data:e,synced:!1,lastModified:(new Date).toISOString()},i=r.add(n);i.onsuccess=()=>s(i.result),i.onerror=()=>a(i.error)})}async updateData(t,e){return this.db||await this.init(),new Promise((s,a)=>{const r=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data),n=r.get(t);n.onsuccess=()=>{const t=n.result;if(t){t.data=e,t.lastModified=(new Date).toISOString(),t.synced=!1;const n=r.put(t);n.onsuccess=()=>s(),n.onerror=()=>a(n.error)}else a(new Error("Data not found"))},n.onerror=()=>a(n.error)})}async getData(t){return this.db||await this.init(),new Promise((e,s)=>{const a=this.db.transaction([this.stores.data],"readonly").objectStore(this.stores.data).index("type").getAll(t);a.onsuccess=()=>e(a.result),a.onerror=()=>s(a.error)})}async getUnsyncedData(){return this.db||await this.init(),new Promise((t,e)=>{const s=this.db.transaction([this.stores.data],"readonly").objectStore(this.stores.data).index("synced").getAll(0);s.onsuccess=()=>t(s.result),s.onerror=()=>e(s.error)})}async markAsSynced(t){return this.db||await this.init(),new Promise((e,s)=>{const a=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data),r=a.get(t);r.onsuccess=()=>{const t=r.result;if(t){t.synced=!0;const r=a.put(t);r.onsuccess=()=>e(),r.onerror=()=>s(r.error)}else s(new Error("Data not found"))},r.onerror=()=>s(r.error)})}async deleteData(t){return this.db||await this.init(),new Promise((e,s)=>{const a=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data).delete(t);a.onsuccess=()=>e(),a.onerror=()=>s(a.error)})}async addToSyncQueue(t){return this.db||await this.init(),new Promise((e,s)=>{const a=this.db.transaction([this.stores.syncQueue],"readwrite").objectStore(this.stores.syncQueue),r={...t,timestamp:(new Date).toISOString(),retryCount:0},n=a.add(r);n.onsuccess=()=>e(n.result),n.onerror=()=>s(n.error)})}async getSyncQueue(){return this.db||await this.init(),new Promise((t,e)=>{const s=this.db.transaction([this.stores.syncQueue],"readonly").objectStore(this.stores.syncQueue).getAll();s.onsuccess=()=>{const e=s.result.sort((t,e)=>{const s={high:0,medium:1,low:2},a=(s[t.priority]||2)-(s[e.priority]||2);return 0!==a?a:new Date(t.timestamp).getTime()-new Date(e.timestamp).getTime()});t(e)},s.onerror=()=>e(s.error)})}async updateSyncQueueItem(t,e){return this.db||await this.init(),new Promise((s,a)=>{const r=this.db.transaction([this.stores.syncQueue],"readwrite").objectStore(this.stores.syncQueue),n=r.get(t);n.onsuccess=()=>{const t=n.result;if(t){Object.assign(t,e);const n=r.put(t);n.onsuccess=()=>s(),n.onerror=()=>a(n.error)}else a(new Error("Sync queue item not found"))},n.onerror=()=>a(n.error)})}async removeSyncQueueItem(t){return this.db||await this.init(),new Promise((e,s)=>{const a=this.db.transaction([this.stores.syncQueue],"readwrite").objectStore(this.stores.syncQueue).delete(t);a.onsuccess=()=>e(),a.onerror=()=>s(a.error)})}async clearAllData(){return this.db||await this.init(),new Promise((t,e)=>{const s=this.db.transaction([this.stores.data,this.stores.syncQueue],"readwrite");let a=0;const r=()=>{a++,2===a&&t()},n=s.objectStore(this.stores.data),i=s.objectStore(this.stores.syncQueue),o=n.clear(),c=i.clear();o.onsuccess=r,c.onsuccess=r,o.onerror=()=>e(o.error),c.onerror=()=>e(c.error)})}async getStorageUsage(){if("storage"in navigator&&"estimate"in navigator.storage){const t=await navigator.storage.estimate();return{used:t.usage||0,quota:t.quota||0}}return{used:0,quota:0}}async exportData(){const[t,e]=await Promise.all([this.getAllData(),this.getSyncQueue()]);return{data:t,syncQueue:e}}async getAllData(){return this.db||await this.init(),new Promise((t,e)=>{const s=this.db.transaction([this.stores.data],"readonly").objectStore(this.stores.data).getAll();s.onsuccess=()=>t(s.result),s.onerror=()=>e(s.error)})}async importData(t){return this.db||await this.init(),new Promise((e,s)=>{const a=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data);let r=0;const n=t.length;if(0===n)return void e();const i=()=>{r++,r===n&&e()};t.forEach(t=>{const{id:e,...r}=t,n=a.add(r);n.onsuccess=i,n.onerror=()=>s(n.error)})})}static getInstance(){return this._instance||(this._instance=new t),this._instance}}const e=t.getInstance();export{t as OfflineStorageService,e as offlineStorage};
