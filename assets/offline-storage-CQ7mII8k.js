class h{dbName="pain-tracker-offline";dbVersion=1;db=null;static _instance=null;stores={data:"offline-data",syncQueue:"sync-queue",cache:"cache-metadata"};async init(){return new Promise((s,a)=>{const n=indexedDB.open(this.dbName,this.dbVersion);n.onerror=()=>a(n.error),n.onsuccess=()=>{this.db=n.result,s()},n.onupgradeneeded=r=>{const e=r.target.result;if(!e.objectStoreNames.contains(this.stores.data)){const t=e.createObjectStore(this.stores.data,{keyPath:"id",autoIncrement:!0});t.createIndex("type","type",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("synced","synced",{unique:!1})}if(!e.objectStoreNames.contains(this.stores.syncQueue)){const t=e.createObjectStore(this.stores.syncQueue,{keyPath:"id",autoIncrement:!0});t.createIndex("priority","priority",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("retryCount","retryCount",{unique:!1})}e.objectStoreNames.contains(this.stores.cache)||e.createObjectStore(this.stores.cache,{keyPath:"url"}).createIndex("expiry","expiry",{unique:!1})}})}async setItem(s,a){try{localStorage.setItem(s,JSON.stringify(a))}catch{}await this.storeData("settings",{key:s,value:a})}async getItem(s){try{const a=localStorage.getItem(s);if(a!==null)return JSON.parse(a)}catch{}try{const n=(await this.getData("settings")).find(r=>r.data&&typeof r.data=="object"&&"key"in r.data&&r.data.key===s);if(n&&n.data&&typeof n.data=="object"&&"value"in n.data)return n.data.value}catch{}return null}makeTableKey(s,a){return`table:${s}:${a}`}parseTableKey(s){if(!s.startsWith("table:"))return null;const a=s.split(":");return a.length<3?null:{table:a[1],id:a.slice(2).join(":")}}async getAllFromTable(s){const a=await this.getData("settings"),n=[];for(const r of a)if(r.data&&typeof r.data=="object"&&"key"in r.data&&"value"in r.data){const e=r.data.key,t=this.parseTableKey(e);t&&t.table===s&&n.push(r.data.value)}return n}async replaceTable(s,a){const n=await this.getData("settings"),r=[];for(const e of n)if(e.id!==void 0&&e.data&&typeof e.data=="object"&&"key"in e.data){const t=e.data.key,o=this.parseTableKey(t);o&&o.table===s&&r.push(this.deleteData(e.id))}await Promise.allSettled(r);for(const e of a){const t=e.id||crypto.randomUUID();await this.storeData("settings",{key:this.makeTableKey(s,String(t)),value:e})}}async addToTable(s,a){const n=a.id||crypto.randomUUID();await this.storeData("settings",{key:this.makeTableKey(s,String(n)),value:{...a,id:n}})}async updateInTable(s,a,n){const r=await this.getData("settings"),e=this.makeTableKey(s,String(a)),t=r.find(o=>o.data&&typeof o.data=="object"&&"key"in o.data&&o.data.key===e);t&&t.id!==void 0?await this.updateData(t.id,{key:e,value:n}):await this.storeData("settings",{key:e,value:n})}async removeFromTable(s,a){const n=await this.getData("settings"),r=this.makeTableKey(s,String(a)),e=n.find(t=>t.data&&typeof t.data=="object"&&"key"in t.data&&t.data.key===r);e&&e.id!==void 0&&await this.deleteData(e.id)}async getFromTable(s,a){const n=await this.getData("settings"),r=this.makeTableKey(s,String(a)),e=n.find(t=>t.data&&typeof t.data=="object"&&"key"in t.data&&t.data.key===r);return e&&e.data&&typeof e.data=="object"&&"value"in e.data?e.data.value:null}async storeData(s,a){return this.db||await this.init(),new Promise((n,r)=>{const t=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data),o={timestamp:new Date().toISOString(),type:s,data:a,synced:!1,lastModified:new Date().toISOString()},i=t.add(o);i.onsuccess=()=>n(i.result),i.onerror=()=>r(i.error)})}async updateData(s,a){return this.db||await this.init(),new Promise((n,r)=>{const t=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data),o=t.get(s);o.onsuccess=()=>{const i=o.result;if(i){i.data=a,i.lastModified=new Date().toISOString(),i.synced=!1;const c=t.put(i);c.onsuccess=()=>n(),c.onerror=()=>r(c.error)}else r(new Error("Data not found"))},o.onerror=()=>r(o.error)})}async getData(s){return this.db||await this.init(),new Promise((a,n)=>{const o=this.db.transaction([this.stores.data],"readonly").objectStore(this.stores.data).index("type").getAll(s);o.onsuccess=()=>a(o.result),o.onerror=()=>n(o.error)})}async getUnsyncedData(){return this.db||await this.init(),new Promise((s,a)=>{const t=this.db.transaction([this.stores.data],"readonly").objectStore(this.stores.data).index("synced").getAll(0);t.onsuccess=()=>s(t.result),t.onerror=()=>a(t.error)})}async markAsSynced(s){return this.db||await this.init(),new Promise((a,n)=>{const e=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data),t=e.get(s);t.onsuccess=()=>{const o=t.result;if(o){o.synced=!0;const i=e.put(o);i.onsuccess=()=>a(),i.onerror=()=>n(i.error)}else n(new Error("Data not found"))},t.onerror=()=>n(t.error)})}async deleteData(s){return this.db||await this.init(),new Promise((a,n)=>{const t=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data).delete(s);t.onsuccess=()=>a(),t.onerror=()=>n(t.error)})}async addToSyncQueue(s){return this.db||await this.init(),new Promise((a,n)=>{const e=this.db.transaction([this.stores.syncQueue],"readwrite").objectStore(this.stores.syncQueue),t={...s,timestamp:new Date().toISOString(),retryCount:0},o=e.add(t);o.onsuccess=()=>a(o.result),o.onerror=()=>n(o.error)})}async getSyncQueue(){return this.db||await this.init(),new Promise((s,a)=>{const e=this.db.transaction([this.stores.syncQueue],"readonly").objectStore(this.stores.syncQueue).getAll();e.onsuccess=()=>{const t=e.result.sort((o,i)=>{const c={high:0,medium:1,low:2},d=(c[o.priority]||2)-(c[i.priority]||2);return d!==0?d:new Date(o.timestamp).getTime()-new Date(i.timestamp).getTime()});s(t)},e.onerror=()=>a(e.error)})}async updateSyncQueueItem(s,a){return this.db||await this.init(),new Promise((n,r)=>{const t=this.db.transaction([this.stores.syncQueue],"readwrite").objectStore(this.stores.syncQueue),o=t.get(s);o.onsuccess=()=>{const i=o.result;if(i){Object.assign(i,a);const c=t.put(i);c.onsuccess=()=>n(),c.onerror=()=>r(c.error)}else r(new Error("Sync queue item not found"))},o.onerror=()=>r(o.error)})}async removeSyncQueueItem(s){return this.db||await this.init(),new Promise((a,n)=>{const t=this.db.transaction([this.stores.syncQueue],"readwrite").objectStore(this.stores.syncQueue).delete(s);t.onsuccess=()=>a(),t.onerror=()=>n(t.error)})}async clearAllData(){return this.db||await this.init(),new Promise((s,a)=>{const n=this.db.transaction([this.stores.data,this.stores.syncQueue],"readwrite");let r=0;const e=()=>{r++,r===2&&s()},t=n.objectStore(this.stores.data),o=n.objectStore(this.stores.syncQueue),i=t.clear(),c=o.clear();i.onsuccess=e,c.onsuccess=e,i.onerror=()=>a(i.error),c.onerror=()=>a(c.error)})}async getStorageUsage(){if("storage"in navigator&&"estimate"in navigator.storage){const s=await navigator.storage.estimate();return{used:s.usage||0,quota:s.quota||0}}return{used:0,quota:0}}async exportData(){const[s,a]=await Promise.all([this.getAllData(),this.getSyncQueue()]);return{data:s,syncQueue:a}}async getAllData(){return this.db||await this.init(),new Promise((s,a)=>{const e=this.db.transaction([this.stores.data],"readonly").objectStore(this.stores.data).getAll();e.onsuccess=()=>s(e.result),e.onerror=()=>a(e.error)})}async importData(s){return this.db||await this.init(),new Promise((a,n)=>{const e=this.db.transaction([this.stores.data],"readwrite").objectStore(this.stores.data);let t=0;const o=s.length;if(o===0){a();return}const i=()=>{t++,t===o&&a()};s.forEach(c=>{const{id:d,...l}=c,u=e.add(l);u.onsuccess=i,u.onerror=()=>n(u.error)})})}static getInstance(){return this._instance||(this._instance=new h),this._instance}}const y=h.getInstance();export{h as OfflineStorageService,y as offlineStorage};
//# sourceMappingURL=offline-storage-CQ7mII8k.js.map
